{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QSPy: Quantitative Systems Pharmacology in Python","text":"<p><code>QSPy</code> (pronounced \"Cue Ess Pie\") is a Python framework for building modular, rule-based models that describe drug behavior and pharmacological interactions within biological systems. Leveraging the power of PySB, it streamlines the development, simulation, and analysis of quantitative systems pharmacology (QSP) models through a reproducible and programmatic approach.</p> <p> Getting Started  How-To Guides Build Model Share Model</p> <p>API Documentation   Need Help?   About QSPy Contributing</p> <p></p> <p>Navig-8 says:</p> <p>Thanks for exploring QSPy! This project is still in early development, so your feedback and support are especially important. You can help us continue to make QSPy better! </p> <p>Leave Feedback Other Ways to Support the Project</p> <p></p>"},{"location":"about-qspy/","title":"About QSPy","text":""},{"location":"about-qspy/#why-qspy","title":"Why <code>QSPy</code>?","text":"<ul> <li>Programmatic Modeling \u2013 Enables automated workflows, reproducibility (e.g., version control and automated testing), customization, and creation of reusable functions for pharmacological and biochemical processes.</li> <li>Built-in Support for Mechanistic Modeling \u2013 QSPy is built on PySB's mechanistic modeling framework, allowing you to incorporate biochemical mechanisms and build customized mechanistic PK/PD and QSP/QST models.</li> <li>Rule-Based Approach \u2013 Encode complex pharmacological and biochemical processes using intuitive rule-based modeling. No need to enumerate all reactions/molecular species or manually encode the corresponding network of differential equations.</li> <li>Python-Based \u2013 Seamlessly integrates with Python\u2019s scientific computing ecosystem, supporting advanced simulations, data analysis, and visualization.</li> <li>Arbitrary Number of Compartments \u2013 Specify any number of compartments to build custom multi-compartment models, including complex drug distribution and physiologically-based pharmacokinetic (PBPK) models.</li> <li>Enhanced reproducibility and reporting - With built in tools like the <code>ModelChecker</code> and <code>ModelMetadataTracker</code>, you can automatically catch potential issues with model structure or components early while also tracking relevant metadata for downstream reproduction and reporting.   </li> <li>Open-Source - QSPy is free and open-source, meaning it is freely available and fully customizable.</li> </ul>"},{"location":"about-qspy/#key-features","title":"Key Features","text":"<ul> <li>Contextualized model definition - QSPy introduces a block-based extension of the PySB domain-specific language (DSL) that organizes model components (monomers, parameters, rules, etc.) into named contexts, more closely mimicking the feel of traditional, block-based, DSLs like BioNetGen, rxode2, and mrgsolve. This structure streamlines model definition and improves readability, while remaining fully interoperable with standard class-based definitions and preserving the full flexibility of PySB\u2019s Python-embedded framework.</li> </ul> PySB  components QSPy contexts <ul> <li> <p>Native support for units - In QSPy, models and their parameters can be assigned physical units (e.g., <code>mg</code>, <code>nM</code>, <code>hr\u207b\u00b9</code>, <code>L/min</code>), enabling automatic conversions, dimensional analysis, and consistency checking.</p> </li> <li> <p>Initial model validation tools - QSPy provides a <code>ModelChecker</code> utility that automatically identifies unused components, zero-valued parameters, missing initial conditions, and overdefined reactions. Warnings are surfaced in real time during model import, with structured logs exported for reproducibility and review.</p> </li> <li> <p>Metadata tracking - QSPy includes a <code>ModelMetadataTracker</code> object that attaches key information, such as author, model version, Python environment, and package versions, directly to the model. This metadata can be exported to a <code>.toml</code> file that's both human- and machine-readable, making it easy to track provenance and support downstream reporting or validation workflows.</p> </li> <li> <p>Built-in logging - Model construction steps, metadata, and redacted provenance are logged to <code>.qspy/</code> folders, giving you a reproducible and inspectable trail for every model version.</p> </li> <li> <p>Functional monomer tagging - QSPy introduces structured tags for classifying monomer components by biological role or modeling intent: e.g., <code>PROTEIN.RECEPTOR</code> and <code>DRUG.INHIBITOR</code>. These tags add additional expressiveness to model species and enable an additional way to filter monomer components for searches and analyses. <pre><code># Using @ operator\nMonomer('Drug', ['b']) @ DRUG.INHIBITOR\n\n# Using @= operator\nMonomer('Target', ['b'])\nTarget @= PROTEIN.RECEPTOR\n\n# Inside monomers context\nwith monomers():\n    Decoy = (['b'], None, PROTEIN.RECEPTOR)\n</code></pre></p> </li> </ul>"},{"location":"about-qspy/#acknowledegments","title":"Acknowledegments","text":"<p>Special thanks for Martin Breuss's MkDocs tuorial, which served as the template for setting up and generating documentation using Mkdocs.</p> <p>AI Acknowledgement</p> <p>Generative AI tools, including ChatGPT, Microsoft Copilot, and GitHub Copilot, were used to brainstorm features and implementation details, draft initial code snippets and boilerplate, and support documentation through outlining, editing, and docstring generation.</p>"},{"location":"citing/","title":"Citing","text":"<p>If you use <code>QSPy</code> in your research, publications, or projects, we kindly ask that you cite it!</p> <p>APA:</p> <p>Blake, W., (2025). QSPy (Version 0.1.0) [Computer software]. https://github.com/Borealis-BioModeling/qspy</p> <p>BibTex:</p> <pre><code>@software{BlakeW_qspy-2025,\nauthor = {Blake, Wilson},\nlicense = {BSD-2-Clause},\ntitle = {{QSPy}},\nurl = {https://github.com/Borealis-BioModeling/qspy},\nversion = {0.1.0},\nyear = {2025}\n}\n</code></pre>"},{"location":"contact-support/","title":"Contact &amp; Support","text":"<p>Feel to reach out through the following channels:</p> <ul> <li>Issues  : Please open a GitHub Issue to   report any problems/bugs with the code or its execution, or to make any feature requests.</li> <li>Discussions  : If you have questions, suggestions, or want to discuss anything else related to the project, feel free to use the QSPy Discussions board.</li> <li>Support  : For any other support inquiries you can reach out in the Support room of our Gitter chat: .</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Development is centered around the qspy GitHub project page.</p>"},{"location":"contributing/#getting-involved","title":"Getting Involved","text":"<p>Here\u2019s are a couple of non-code ways you can get involved:</p> <ul> <li>Issues  : Please open a GitHub Issue to report any problems/bugs with the code or its execution, or to make any feature requests.</li> <li>Discussions  : If you have questions, suggestions, or want to discuss anything else related to the project, feel free to use the Discussions board.</li> </ul>"},{"location":"contributing/#contributing-code","title":"Contributing Code","text":"<p>Contributions are welcomed! If you\u2019d like to improve <code>qspy</code>, see the Contributing Guide.</p>"},{"location":"contributing/#sharing-models","title":"Sharing Models","text":"<p>Developed a model using <code>qspy</code>? Feel free to share it with us in this GitHub Discussion! </p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>All contributions will be considered based solely on their quality and fit with the overall direction of the project.   </p> <p>All contributors are expected to be kind and respectful to one another. Behavior that is harmful to your fellow contributors is not acceptable.</p>"},{"location":"experimental/","title":"Experimental Features in QSPy","text":"<p>The <code>qspy.experimental</code> module provides early-access APIs and advanced modeling features that are not yet part of the stable QSPy release. These features are intended for prototyping and feedback. Please try them out and let us know what you think!</p> <p>Warning</p> <p>Experimental features may not be stable or properly tested. They may also change dramatically or be removed in future versions.</p>"},{"location":"experimental/#overview","title":"Overview","text":"<p>Experimental features in QSPy include:</p> <ul> <li>Functional Monomers: Classes, mixins, protein-specific monomers, and advanced macros for building and manipulating functional monomers.</li> <li>Infix Macros: Expressive infix-style macros for model specification, enabling readable code for binding, elimination, and equilibrium reactions.</li> </ul>"},{"location":"experimental/#functional-monomers","title":"Functional Monomers","text":"<p>Located in <code>qspy.experimental.functional_monomers</code>, this subpackage provides:</p> <ul> <li><code>FunctionalMonomer</code>: Base class for monomers with functional tags and base states.</li> <li>Mixins for binding (<code>BindMixin</code>), synthesis (<code>SynthesizeMixin</code>), and degradation (<code>DegradeMixin</code>).</li> </ul>"},{"location":"experimental/#protein-specific-classes","title":"Protein-Specific Classes","text":"<ul> <li><code>Ligand</code>: Class for ligand monomers with binding functionality.</li> <li><code>Receptor</code>: Class for receptor monomers with orthosteric/allosteric binding and activation logic.</li> </ul> <p>Example: <pre><code>from qspy.experimental.functional_monomers.protein import Ligand, Receptor\n\nlig = Ligand(\"LigandA\")\nrec = Receptor(\"ReceptorA\")\n\n# Define binding and turnover reactions\nlig.binds_to(rec, \"b_ortho\", k_f, k_r)\nrec.turnover(k_syn, k_deg)\n</code></pre></p>"},{"location":"experimental/#advanced-macros","title":"Advanced Macros","text":"<ul> <li><code>activate_concerted</code>: For concerted activation of a receptor by a ligand, combining binding and state change in one step.</li> </ul> <p>Example: <pre><code>from qspy.experimental.functional_monomers.macros import activate_concerted\n\nactivate_concerted(\n    ligand, \"b\", receptor, \"b\",\n    {\"state\": \"inactive\"}, {\"state\": \"active\"},\n    [k_f, k_r]\n)\n</code></pre></p>"},{"location":"experimental/#infix-macros","title":"Infix Macros","text":"<p>Located in <code>qspy.experimental.infix_macros</code>, these macros allow for expressive, readable model code using infix-like chemical/biological/pharmcological operators:</p> <ul> <li><code>*binds*</code>: For reversible binding reactions.</li> <li><code>*eliminated*</code>: For elimination reactions.</li> <li><code>*equilibrates*</code>: For reversible state transitions.</li> </ul> <p>Example: <pre><code>from qspy.experimental.infix_macros import binds, eliminated, equilibrates\n\n# Reversible binding\nspecies1 *binds* species2 @ ('binding_site1', 'binding_site2') &amp; (k_f, k_r)\n## OR\nspecies1(binding_site1=None) *binds* species2(binding_site2=None) &amp; (k_f, k_r)\n\n# Elimination\nspecies *eliminated* compartment &amp; k_elim\n\n# State equilibrium\nstate1 *equilibrates* state2 &amp; (k_f, k_r)\n</code></pre></p>"},{"location":"experimental/#usage-notes","title":"Usage Notes","text":"<ul> <li>API Stability: Experimental features may change without notice. Use with caution in production models.</li> <li>Feedback: User feedback is welcome! Please report issues or suggestions to the QSPy development team.</li> <li>Documentation: Experimental features may have limited documentation. Refer to source code and docstrings for details.</li> </ul>"},{"location":"experimental/#how-to-import","title":"How to Import","text":"<p>Experimental features are not imported by default. You must explicitly import them from the <code>qspy.experimental</code> namespace:</p> <pre><code>from qspy.experimental.infix_macros import binds, eliminated\nfrom qspy.experimental.functional_monomers.protein import Ligand, Receptor\n</code></pre>"},{"location":"experimental/#contributing","title":"Contributing","text":"<p>We want to know how useful these experimental features are, and how well they work with your modeling workflows. So, please try them out and let us know what you think through any of our contact/support channels, and you can report any functional issues using the GitHub Issue tracker.</p> <p>If you have ideas for new experimental features, please reach out to share your ideas, or see our Contributing Guidelines if you want to contribute code. </p>"},{"location":"functional-tags/","title":"Functional Tags for Monomers in QSPy","text":"<p>In QSPy, functional tags annotate monomers with biologically or computationally meaningful labels. These tags express a class/function relationship\u2014such as marking a species as a <code>receptor</code>, adding additional expressiveness to model species while also supporting another way to filter monomers.</p>"},{"location":"functional-tags/#tagging-semantics","title":"Tagging Semantics","text":"<ul> <li>Tags indicate class and function/subclass roles.</li> <li>Each monomer can have a single tag.</li> <li>Tags improve:</li> <li>Model expressiveness</li> <li>Filtering by biological function</li> </ul> <p>Functional tags are in all caps and have the following pattern in model definitions:</p> <pre><code>CLASS.FUNCTION\n</code></pre>"},{"location":"functional-tags/#python-example","title":"Python Example","text":"<pre><code>    with monomers():\n        drug = (['b'], None, DRUG.INHIBITOR)\n</code></pre> <p>Functional tags are accesible by a monomer's <code>functional_tag</code> attribute:</p> <pre><code>&gt;&gt;&gt; print(drug.functional_tag)\n</code></pre> <pre><code>FunctionalTag(class_='drug', function='inhibitor')\n</code></pre>"},{"location":"functional-tags/#recognized-classes-and-functions","title":"Recognized Classes and Functions","text":"<p>The table below lists standardized tags currently used in QSPy.</p> Class Tag Function/Subclass Description <code>DRUG</code> <code>SMALL_MOLECULE</code>, <code>BIOLOGIC</code>, <code>ANTIBODY</code>, <code>MAB</code>, <code>INHIBITOR</code>, <code>AGONIST</code>, <code>ANTAGONIST</code>, <code>INVERSE_AGONIST</code>, <code>MODULATOR</code>, <code>ADC</code>, <code>RLT</code>, <code>PROTAC</code>, <code>IMMUNOTHERAPY</code>, <code>CHEMOTHERAPY</code> Therapeutic agents <code>PROTEIN</code> <code>LIGAND</code>, <code>RECEPTOR</code>, <code>RECEPTOR_DECOY</code>, <code>KINASE</code>, <code>PHOSPHATASE</code>, <code>ADAPTOR</code>, <code>TRANSCRIPTION_FACTOR</code>, <code>ENZYME</code>, <code>ANTIBODY</code> Biologically active protein-based macromolecules <code>RNA</code> <code>MESSENGER</code>, <code>MICRO</code>, <code>SMALL_INTERFERING</code>, <code>LONG_NONCODING</code> Transcribed nucleic acids involved in gene expression, regulation, or signal propagation <code>METABOLITE</code> <code>SUBSTRATE</code>, <code>PRODUCT</code>, <code>COFACTOR</code> Small molecules involved in biochemical reactions, such as intermediates, reactants, and regulatory modulators <code>LIPID</code> <code>EICOSANOID</code>, <code>PHOSPHOLIPID</code>, <code>GLYCOLIPID</code>, <code>STEROL</code> Hydrophobic or amphipathic molecules involved in signaling or other biological functions <code>ION</code> <code>CALCIUM</code>, <code>CHLORIDE</code>, <code>MAGNESIUM</code>, <code>SODIUM</code>, <code>POTASSIUM</code> Charged atoms or small molecules involved in electrochemical signaling, osmotic balance, and catalysis <code>NANOPARTICLE</code> <code>DRUG_DELIVERY</code>, <code>IMAGING</code>, <code>SENSING</code>, <code>THERMAL</code>, <code>THERANOSTIC</code> Engineered nanoscale particles designed for targeted delivery, imaging enhancement, or localized therapeutic functions"},{"location":"functional-tags/#custom-tags","title":"Custom tags","text":"<p>Users can define custom tags. For consistency, follow the schema above when possible.</p> <p>Functional tags are subclasses of the <code>enum.Enum</code> object and can be defined as below:</p> <pre><code>from enum import Enum\nfrom qspy.functionaltags import prefixer\n\nMY_TAG_PREFIX = \"mytag\"\nclass MY_TAG(Enum):\n    FUNCTION = prefixer(\"function\", MY_TAG_PREFIX)\n    SUBCLASS = prefixer(\"subclass\", MY_TAG_PREFIX)\n</code></pre> <p>Then, you can use the custom tag like any other:</p> <pre><code>with monomers():\n    A = (None, None, MY_TAG.FUNCTION)\n\nMonomer('B') @ MY_TAG.SUBCLASS\n</code></pre>"},{"location":"getting-started/","title":"Getting Started with QSPy","text":""},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#dependencies","title":"Dependencies","text":"<p><code>QSPy</code> has the following core dependencies:</p> <ul> <li>PySB</li> <li>pysb-pkpd</li> <li>pysb-units</li> <li>Microbench</li> <li>PyViPR</li> <li>MerGram</li> </ul>"},{"location":"getting-started/#installation-steps","title":"Installation steps","text":"<ol> <li>Install PySB using conda or mamba:</li> </ol> <pre><code>conda install -c alubbock pysb\n</code></pre> <p>OR</p> <pre><code>mamba install -c alubbock pysb\n</code></pre> <ol> <li>Install qspy with pip:</li> </ol> <pre><code>pip install cueesspie\n</code></pre> <p>Ensure you have Python 3.11.3+ and PySB 1.15.0+ installed.</p>"},{"location":"getting-started/#quick-start-example","title":"Quick-start Example","text":"<pre><code>from qspy import *\nfrom qspy.functionaltags import PROTEIN, DRUG\nfrom qspy.validation import ModelMetadataTracker, ModelChecker\n\nModel(name=\"SimpleQSP\").with_units(concentration='nM', time='1/s', volume='L')\n\nwith parameters():\n    k_f = (1.0, \"1/min\")\n    k_r = (0.5, \"1/min\")\n    L_0 = (100.0, \"nM\")\n    R_0 = (10.0, \"nM\")\n\nwith monomers():\n    L = ([\"b\"], {}, DRUG.AGONIST)\n    R = ([\"b\", 'active'], {'active':[False, True]}, PROTEIN.RECEPTOR)\n\nwith rules():\n    bind = (L(b=None) + R(b=None, active=False) | L(b=1) % R(b=1, active=True),\n    k_f, k_r)\n\nwith initials():\n    L(b=None) &lt;&lt; L_0\n    R(b=None, active=False) &lt;&lt; R_0\n\nwith observables():\n    L() &gt; \"L_total\"\n    R() &gt; \"R_total\"\n    R(active=True) &gt; \"R_active\"\n\n# Track and export model metadata\nModelMetadataTracker(version=\"1.0.0\", author=\"Alice\", export_toml=True)\n\n# Run model validation checks\nModelChecker()\n\nif __name___ == \"__main__\"\n    # Generate a Markdown summary\n    model.markdown_summary()\n</code></pre>"},{"location":"how-to-guides/","title":"How-To Guides","text":""},{"location":"how-to-guides/#how-to-simulate-a-model","title":"How to Simulate a Model","text":"<p><code>qspy</code> provides a <code>simulate</code> function that can be used to easily execute a dynamic ODE-based simulation of your QSP model as below:</p> <pre><code>import numpy as np\nfrom qspy import simulate\nfrom my_qsp_model import model\n\n# Simulate the QSP/PKPD/PySB model.\n## Set the timespan for the simulation:\ntspan = np.arange(241) # 0-240 seconds at 1 second intervals\n## Execute the simulation:\nsimulation_trajectory = simulate(model, tspan)\n</code></pre>"},{"location":"how-to-guides/#how-to-filter-a-models-monomers-by-functional-tag","title":"How to filter a model's monomers by functional tag","text":"<pre><code>from qspy.functionaltags import *\nfrom my_qsp_model import model\n\n# Get all the monomers tagged as protein receptors\nreceptors = model.monomers.filter(lambda m: m.functional_tag == PROTEIN.RECEPTOR)\n# Get all the monomers tagged as inhibitor drugs\ninhibitors = model.monomers.filter(lambda m: m.functional_tag == DRUG.INHIBITOR)\n</code></pre>"},{"location":"how-to-guides/#how-to-define-custom-monomer-functional-tags","title":"How to define custom monomer functional tags","text":"<p>See Functional Tags: Custom Tags</p>"},{"location":"how-to-guides/#page-still-under-development","title":"\ud83d\udea7 Page Still Under Development \ud83d\udea7","text":"<p>Thank you for your interest in our How-To Guides section! We\u2019re actively working on expanding these pages to provide step-by-step instructions and hands-on examples for using <code>qspy</code>.</p> <p>Our goal is to make these resources clear, practical, and easy to follow\u2014but we\u2019re still in the process of gathering content and refining details.</p> <p>Stay tuned! In the meantime:</p> <ul> <li>Have a specific question? Feel free to explore our existing documentation or reach out to the community.</li> <li>Want to contribute? If you have suggestions or example workflows, we'd love to hear from you!</li> </ul> <p>Check back soon for updates as we continue to improve these guides!</p>"},{"location":"license/","title":"BSD 2-Clause License","text":"<p>Copyright (c) 2025, Borealis BioModeling (Blake A. Wilson)</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"metadata-tracking/","title":"Model Metadata Tracking in QSPy","text":"<p>QSPy provides robust metadata tracking for all models using the <code>ModelMetadataTracker</code> class. This enables reproducibility, provenance, and environment capture for quantitative systems pharmacology (QSP) workflows.</p>"},{"location":"metadata-tracking/#what-is-modelmetadatatracker","title":"What is <code>ModelMetadataTracker</code>?","text":"<p><code>ModelMetadataTracker</code> is a utility class that captures and manages metadata about your QSPy model, including:</p> <ul> <li>Model version, author, and creation timestamp</li> <li>The current user and environment details (Python, OS, package versions)</li> <li>A hash of the model's rules and parameters (for provenance)</li> <li>Optional export to TOML for archiving and sharing</li> </ul> <p>Metadata is automatically attached to the model instance and can be exported or loaded as needed.</p>"},{"location":"metadata-tracking/#typical-usage","title":"Typical Usage","text":""},{"location":"metadata-tracking/#1-automatic-tracking","title":"1. Automatic Tracking","text":"<p>When you instantiate <code>ModelMetadataTracker</code>, it attaches itself to the current PySB/QSPy model:</p> <pre><code>from qspy.validation.metadata import ModelMetadataTracker\n\nModel().with_units(...)\n...\n...\n\n# After building your model\nModelMetadataTracker(version=\"1.0\", author=\"Alice\", export_toml=True)\n</code></pre> <ul> <li>The tracker will automatically attach itself to <code>model.qspy_metadata_tracker</code>.</li> <li>Metadata is available as a dictionary: <code>model.qspy_metadata_tracker.metadata</code></li> <li>If <code>export_toml=True</code>, metadata is saved to a TOML file your configured metadata directory (<code>.qspy</code> by default).</li> </ul>"},{"location":"metadata-tracking/#2-accessing-metadata","title":"2. Accessing Metadata","text":"<p>You can access the metadata dictionary at any time:</p> <pre><code>meta = model.qspy_metadata_tracker.metadata\nprint(meta[\"model_name\"])\nprint(meta[\"hash\"])\nprint(meta[\"env\"])  # Environment details\n</code></pre>"},{"location":"metadata-tracking/#3-exporting-and-loading-metadata","title":"3. Exporting and Loading Metadata","text":"<p>Export metadata to a TOML file:</p> <pre><code>model.qspy_metadata_tracker.export_metadata_toml() # Auto-generates filename\nmodel.qspy_metadata_tracker.export_metadata_toml(path=\"custom_metadata.toml\")\n</code></pre> <p>Load metadata from a TOML file:</p> <pre><code>from qspy.validation.metadata import ModelMetadataTracker\n\nmeta = ModelMetadataTracker.load_metadata_toml(\"MyModel__Alice__abcd1234__2024-07-01.toml\")\nprint(meta[\"version\"])\n</code></pre> <p>Example</p> <pre><code>from qspy.validation.metadata import ModelMetadataTracker\n\n# Build your model here...\n\n# Track and export metadata\ntracker = ModelMetadataTracker(version=\"2.0.1\", author=\"Bob\", export_toml=True)\n\n# Access metadata\nprint(tracker.metadata[\"model_name\"])\nprint(tracker.metadata[\"created_at\"])\nprint(tracker.metadata[\"env\"][\"platform\"])\n</code></pre>"},{"location":"metadata-tracking/#why-use-metadata-tracking","title":"Why Use Metadata Tracking?","text":"<ul> <li>Reproducibility: Know exactly which code, environment, and parameters produced your results.</li> <li>Provenance: Track model changes and authorship over time.</li> <li>Environment Capture: Record Python, OS, and package versions for future reference.</li> <li>Archival: Export metadata alongside your model for publication or collaboration.</li> </ul>"},{"location":"model-checker/","title":"<code>ModelChecker</code>: Validating Model Integrity in QSPy","text":"<p>The <code>ModelChecker</code> is QSPy's built-in utility for diagnosing and validating model integrity before simulation. It inspects models to identify potential errors, such as unused components, zero-valued parameters, missing initial conditions and lack consistency amongst physical units. Errors and warnings are surfaced in real time during model import, with structured logs exported for reproducibility and review.</p>"},{"location":"model-checker/#key-features","title":"Key Features","text":"<p>Includes checks for:</p> <ul> <li>Unused components: Warns of any unused monomers or parameters.</li> <li>Zero-valued parameters: Warns of any parameters with a value of zero.</li> <li>Dangling or Re-used bonds: Raises errors for any dangling or re-used bonds in reaction rules.</li> <li>Units Checks: Warns of any duplicate, inconsistent, or missing units.</li> </ul>"},{"location":"model-checker/#importing-and-instantiating","title":"Importing and Instantiating","text":"<p>Inside model definition:</p> <pre><code>from qspy.validation import ModelChecker\n...\nModel().with_units(...)\n...\n...\n# Runs validation checks when model is imported.\nModelChecker()\n</code></pre> <p>Outside of model definition:</p> <pre><code>from qspy.validation import ModelChecker\nfrom my_model import model  # build programmatically\n\nchecker = ModelChecker(model)\n</code></pre>"},{"location":"model-components/","title":"Model Components","text":""},{"location":"model-components/#from-pysb-to-qspy-building-with-context","title":"From PySB to QSPy: Building with Context","text":"<p>At its core, QSPy builds on PySB (Python Systems Biology modeling), a Python-embedded domain specific language (DSL) for rule-based modeling of biochemical systems. PySB models are constructed from core components such as Monomers, Parameters, Rules, Initials, and Observables. It adopts an object-oriented approach to model building, enhanced with syntactic sugar for automatic component registration (self-exporting) and a chemistry-inspired rule syntax based on BNGL (BioNetGen Language). QSPy preserves this foundational API while introducing an alternative, structured, context-based approach to model definition. </p> <p>Instead of directly initializing instances of component classes, QSPy allows grouping them into named contexts using Python <code>with</code> blocks.</p> <p>Example</p> <pre><code>with monomers():\n    Ligand = ([\"r\"], None, PROTEIN.LIGAND)\n    Receptor = ([\"l\"], None, PROTEIN.RECEPTOR)\n</code></pre> <p>Where applicable, QSPy then parses the inputs into the desired model components during the context exit process. As in PySB, the component names are exported into the current namespace, and the components can be programmatically manipulated.</p> <p>Example</p> <pre><code>print(Ligand)\n</code></pre> <pre><code>&gt;&gt;&gt; Monomer(\"Ligand\", ['r']) @ protein::ligand\n</code></pre> <p>This organizational style mimics the block-based structure of classic declarative DSLs, such as BNGL and rxode2 model specificaitons, while preserving the flexibility of a programmatic Python environment. The goal is to further streamline model encoding and improve readability by minimizing boilerplate and promoting semantic grouping of related model components. </p> <p>Note</p> <p>QSPy contexts also incorporate logging functionality to help users track component additions and audit model assembly for reproducibility.</p> <p>The sections that follow describe each model component and how QSPy extends their definition.</p>"},{"location":"model-components/#the-model-object","title":"The Model Object","text":"<p>Every QSPy model builds upon a central <code>Model</code> object that serves as the container for all biological components, relationships, and metadata. This object is an extension of the standard PySB <code>Model</code> object, with additional hooks for logging, metadata tracking, and QSPy\u2019s context-aware construction pattern, as well as additional utilities for setting global model units and outputting model summaries to Markdown files.</p> <p>As with PySB, a new <code>Model</code> is typically specified in Python module file (e.g., <code>model.py</code>). When you define a <code>Model</code> in QSPy, a global <code>model</code> object is automatically available like in PySB. All subsequent context blocks, such as <code>with monomers()</code> or with <code>parameters()</code>, register their components to this object. Also, as in PySB, any model components created using their class-based objects, such as <code>Parameter(...)</code> or <code>Rule(...)</code>, are also automatically registered to the model object.</p> <pre><code>Model().with_units(concentration=\"mg/L\", time=\"h\", volume=\"L\")\n</code></pre> <p>As above, we recommend always chaining <code>Model</code> initialization with the <code>with_units</code> function to set global model units for concentration, time, and volume; all subsequent parameter definitions with these unit types will be automatically converted and appropriately scaled behind the scenes during model import.</p> <p>After model specification (e.g., in <code>my_model.py</code>), the <code>model</code> object can imported and used accordingly.</p> <pre><code>from my_model import model\n</code></pre>"},{"location":"model-components/#monomers","title":"Monomers","text":"<p><code>Monomer</code>s represent fundamental molecular and biological species, such as drugs, proteins, or receptors. They have sites and site states, and can also be assigned a functional tag. Sites may represent binding regions or other modifiable molecular features, such as phosphorylation sites with distinct states (e.g., unphosphorylated <code>'u'</code> and phosphorylated <code>'p'</code>). </p> With <code>monomers</code> context:Context-free equivalent <pre><code>with monomers():\n    Ligand = ([\"r\"], None, DRUG.INHIBITOR)\n    Receptor = ([\"l\"], None, PROTEIN.RECEPTOR)\n</code></pre> <pre><code>Monomer(\"Ligand\", ['r']) @ DRUG.INHIBITOR\nMonomer(\"Receptor\", ['l']) @ PROTEIN.RECEPTOR\n</code></pre> <p>Note</p> <p>Inside the <code>monomers</code> context the assignment pattern is:</p> <pre><code>monomer_name = (sites_list, site_states_dict, functional_tag)\n</code></pre> <p>Also, assigning a functional tag inside the <code>monomers</code> context is optional, so the following pattern is also valid:</p> <pre><code>with monomers():\n    Ligand = ([\"r\"], None)\n    Receptor = ([\"l\"], None)\n</code></pre> <p>QSPy enhancements</p> <ul> <li>Functional tagging (e.g., <code>PROTEIN.RECEPTOR</code>, <code>DRUG.INHIBITOR</code>), including new overloaded <code>@</code> operator for functional tag assignments.</li> <li>Contextual grouping with automatic introspection for monomer creation and naming (when using <code>monomers</code> context).</li> </ul>"},{"location":"model-components/#parameters","title":"Parameters","text":"<p><code>Parameter</code>s quantify rate constants, concentrations, or other numeric values.</p> With <code>parameters</code> context:Context-free equivalent: <pre><code>with parameters():\n    kf_bind = (1e-1, \"1/uM/s\")\n    kr_bind = (1e-3, \"1/s\")\n    Ligand_0 = (100, \"nM\")\n</code></pre> <pre><code>Parameter(\"kf_bind\", 1e-1, unit=\"1/uM/s\")\nParameter(\"kr_bind\", 1e-3, unit=\"1/s\")\nParameter(\"Ligand_0\" 100, unit=\"nM\")\n</code></pre> <p>Note</p> <p>inside the <code>parameters</code> context the assignment pattern is:</p> <pre><code>parameter_name = (value, units)\n</code></pre> <p>QSPy enhancements</p> <ul> <li>Native support for units (e.g., mg, nM, hr\u207b\u00b9, L/min)</li> <li>Contextual grouping with automatic introspection for parameter creation and naming (when using <code>parameters</code> context).</li> </ul>"},{"location":"model-components/#rules","title":"Rules","text":"<p><code>Rules</code> define biochemical interactions such as binding or transformation.</p> With <code>rules</code> context:Context-free equivalent: <pre><code>with rules():\n    bind_L_R = (Ligand(r=None) + Receptor(l=None) \n    &gt;&gt; Ligand(r=1) % Receptor(l=1), kf_bind, kr_bind\n    )\n</code></pre> <pre><code>Rule(\"bind_L_R\", Ligand(r=None) + Receptor(l=None) \\\n&gt;&gt; Ligand(r=1) % Receptor(l=1), kf_bind, kr_bind)\n</code></pre> <p>Note</p> <p>inside the <code>rules</code> context the assignment pattern is:</p> <p> reversible reactions:</p> <pre><code>rule_name = (reaction pattern, forward rate consant, reverse rate constant)\n</code></pre> <p> irreversible reactions:</p> <pre><code>rule_name = (reaction pattern, rate constant)\n</code></pre> <p>QSPy enhancements</p> <ul> <li>Contextual grouping with automatic introspection for rule creation and naming (when using <code>rules</code> context).</li> </ul>"},{"location":"model-components/#initial-conditions","title":"Initial Conditions","text":"<p><code>Initial</code>s specify the starting concentrations or states of species in the model.</p> With <code>initials</code> context:Context-free equivalent:Context-free without the <code>&lt;&lt;</code> operator: <pre><code>with initials():\n    Ligand(r=None) &lt;&lt; Ligand_0\n</code></pre> <pre><code>Ligand(r=None) &lt;&lt; Ligand_0\n</code></pre> <pre><code>Initial(Ligand(r=None), Ligand_0)\n</code></pre> <p>QSPy enhancements</p> <ul> <li>Optional grouped <code>initials</code> context for clearer organization and additional logging</li> <li>New overloaded <code>&lt;&lt;</code> operator for initial condition assignment without the need to explicitly initialize an <code>Initial</code> object.</li> </ul>"},{"location":"model-components/#observables","title":"Observables","text":"<p><code>Observable</code>s define measurable quantities derived from model states.</p> With <code>observables</code> context:auto naming using <code>~</code> prefix operator:Context-free equivalent with <code>&gt;</code> operator:Context-free equivalent with <code>~</code> operator:Context-free without the <code>&gt;</code> or <code>~</code> operators: <pre><code>with observables():\n    Ligand(r=1) % Receptor(l=1) &gt; \"BoundComplex\"\n</code></pre> <pre><code>with observables():\n    ~Ligand(r=1) % Receptor(l=1)\n</code></pre> <pre><code>Ligand(r=1) % Receptor(l=1) &gt; \"BoundComplex\"\n</code></pre> <pre><code>~Ligand(r=1) % Receptor(l=1)\n</code></pre> <pre><code>Observable(\"BoundComplex\", Ligand(r=1) % Receptor(l=1))\n</code></pre> <p>QSPy enhancements</p> <ul> <li>Optional grouped <code>observables</code> context for clearer organization and additional logging</li> <li>New overloaded <code>&gt;</code> operator for observable assignment without the need to explicitly initialize an <code>Observable</code> object.</li> <li>New overloaded <code>~</code> operator for observable assignment with an auto-generated name, and without the need to explicitly initialize an <code>Observable</code> object.</li> </ul>"},{"location":"model-components/#expressions","title":"Expressions","text":"<p>Expressions define algebraic relationships between parameters, observables, or other expressions. They\u2019re useful for computing composite values like dose scaling factors, compartment-adjusted concentrations, or feedback-modulated rates.</p> With <code>expressions</code> context:Context-free equivalent: <pre><code>with expressions():\n    K_d = k_r / k_f # dissociation constant\n</code></pre> <pre><code>Expression(\"K_d\", k_r / k_f) # dissociation constant\n</code></pre> <p>QSPy enhancements</p> <ul> <li>Contextual grouping with automatic introspection for expression creation and naming (when using <code>expressions</code> context).</li> </ul>"},{"location":"model-components/#compartments","title":"Compartments","text":"<p><code>Compartment</code>s define spatial contexts for species and reactions, representing physical volumes or surfaces such as plasma, tissue, or organelles.</p> With contextsContext-free equivalent: <pre><code>with parameters():\n    V_C = (10.0, \"L\")\n    V_P = (100.0, \"mL\")\n\nwith compartments():\n    CENTRAL = V_C\n    PERIPHERAL = V_P\n</code></pre> <pre><code>Parameter(\"V_C\", 10.0, unit=\"L\")\nParameter(\"V_P\", 100.0, unit=\"mL\")\n\nCompartment(\"CENTRAL\", size=V_C)\nCompartment(\"PERIPHERAL\", size=V_P)\n</code></pre> <p>QSPy enhancements</p> <ul> <li>Contextual grouping with automatic introspection for compartment creation and naming (when using <code>compartments</code> context).</li> </ul>"},{"location":"model-components/#macros","title":"Macros","text":"<p>Macros in QSPy provide high-level, reusable templates for common biochemical processes such as binding, catalysis, synthesis, degradation, and more. They encapsulate complex rule patterns into a single, expressive statement, improving both readability and maintainability of your model code.</p>"},{"location":"model-components/#background-pysb-macros","title":"Background: PySB Macros","text":"<p>PySB macros are functions that generate sets of rules and components for common biochemical motifs (e.g., reversible binding, catalysis, synthesis, degradation). They are a foundational feature of PySB, enabling concise and readable model code for complex biological processes.</p> <p>QSPy builds on this foundation by:</p> <ul> <li>Incorporating all core PySB macros (<code>pysb.macros</code>) as <code>qspy.macros.core</code> (these include functions like <code>bind</code>, <code>equilibrate</code>, <code>catalyze</code>, etc.)</li> <li>Including the PK/PD macros from <code>pysb-pkpd</code> (<code>pysb.pkpd.macros</code>) as <code>qspy.macros.pkpd</code> (these include PK processes such as <code>distribute</code> and <code>eliminate</code>, PD functions like <code>emax</code>, and <code>sigmoidal_emax</code>, and dosing functions like <code>dose_bolus</code>)</li> <li>Adding native support for units to both sets of macros, so all rate and concentration parameters can be specified with units and are automatically converted and checked</li> </ul> <p>This means you can use all standard PySB macro patterns in QSPy, but with enhanced unit handling and integration with QSPy\u2019s context and logging system.</p>"},{"location":"model-components/#qspy-macro-contexts","title":"QSPy Macro Contexts","text":"<p>You can use macros directly or within the <code>macros</code> context for grouped, introspective macro registration. When using the <code>macros</code> context, all macro-generated components are automatically logged to the QSPy logs for auditability and reproducibility.</p> With <code>macros</code> context:Context-free equivalent: <pre><code>with macros():\n    bind(Ligand(r=None), Receptor(l=None), 'r', 'l', [kf_bind, kr_bind])\n    degrade(Protein(), k_deg)\n</code></pre> <pre><code>bind(Ligand(r=None), Receptor(l=None), 'r', 'l', [kf_bind, kr_bind])\ndegrade(Protein(), k_deg)\n</code></pre> <p>QSPy enhancements</p> <ul> <li>All macros are updated to use unit-aware model components.</li> <li>Contextual grouping with automatic introspection and logging when using the <code>macros</code> context.</li> <li>Full access to both core PySB macros and PK/PD macros from <code>pysb-pkpd</code>.</li> </ul> <p>Macros can greatly simplify the specification of complex reaction patterns, especially when used in combination with QSPy\u2019s context system.</p> <p>For more details on available macros, see the PySB macro documentation and the pysb-pkpd macro documentation.</p>"},{"location":"model-diagram-generator/","title":"ModelMermaidDiagrammer: Visualizing QSPy Models","text":"<p>The <code>ModelMermaidDiagrammer</code> object in the <code>qspy.utils.diagram</code> module provides a convenient way to generate flowchart-style diagrams of your QSPy models using Mermaid. These diagrams help you visualize the structure of your model, including compartments, species, and reactions, and can be embedded in Markdown documentation or exported to standalone files.</p>"},{"location":"model-diagram-generator/#what-is-modelmermaiddiagrammer","title":"What is <code>ModelMermaidDiagrammer</code>?","text":"<p><code>ModelMermaidDiagrammer</code> is a utility class that takes a QSPy or PySB model and produces a Mermaid diagram representing the model's components and their interactions. This is especially useful for documentation, presentations, and model review.</p>"},{"location":"model-diagram-generator/#key-features","title":"Key Features","text":"<ul> <li>Automatic diagram generation from your model structure</li> <li>Compartment, species, and reaction visualization</li> <li>Markdown and HTML export for easy integration with documentation</li> <li>File export to <code>.mmd</code> (Mermaid) format</li> </ul>"},{"location":"model-diagram-generator/#usage","title":"Usage","text":""},{"location":"model-diagram-generator/#basic-example","title":"Basic Example","text":"<pre><code># my_model.py\nfrom qspy.core import Model\nfrom qspy.utils.diagram import ModelMermaidDiagrammer\n\n# Build your model here...\nModel(name=\"MyModel\")\n# ... define monomers, parameters, rules, etc.\n\n# Create a diagram object\nModelMermaidDiagrammer(model)\n</code></pre> <p>then</p> <pre><code># Import your model\nfrom my_model import model\n\n# Get the diagram as a Markdown block\nmarkdown_block = model.mermaid_diagram.markdown_block\n\n# Write the diagram to a Mermaid file\nmodel.mermaid_diagram.write_mermaid_file(\"my_model_diagram.mmd\")\n</code></pre>"},{"location":"model-diagram-generator/#including-in-model-summary","title":"Including in Model Summary","text":"<p>If you attach a <code>ModelMermaidDiagrammer</code> instance to your model (as <code>model.mermaid_diagram</code>), it will be automatically included in the output of <code>model.markdown_summary()</code>:</p>"},{"location":"model-diagram-generator/#example-output","title":"Example Output","text":"<p>A generated Mermaid diagram might look like:</p> <pre><code>graph TD\n    A --&gt;|k_bind| C[A:B]\n    B --&gt;|k_bind| C[A%B]\n</code></pre> <p>When rendered in Markdown or HTML, this will appear as a flowchart showing the relationships between model components.</p>"},{"location":"model-diagram-generator/#why-use-modelmermaiddiagram","title":"Why Use ModelMermaidDiagram?","text":"<ul> <li>Clarity: Visualize complex model structures at a glance.</li> <li>Documentation: Embed diagrams directly in your Markdown docs or reports.</li> <li>Communication: Share model architecture with collaborators and stakeholders.</li> </ul>"},{"location":"model-diagram-generator/#see-also","title":"See Also","text":"<ul> <li>Model Summary Generator</li> <li>Mermaid Documentation</li> </ul>"},{"location":"model-specification/","title":"Building a Model with QSPy","text":"<p>This guide walks through encoding a model directly in Python using QSPy\u2019s core modules. For this purpose, we will build a relatively simple two-compartment semi-mechanistic pharmacokinetics &amp; receptor-occupancy (PKRO) model. Typically, models are defined in their own Python module file: e.g., <code>pkro_model.py</code>.</p>"},{"location":"model-specification/#1-import-essential-modulesobjects","title":"1) Import essential modules/objects","text":"<pre><code>from qspy import *\n</code></pre>"},{"location":"model-specification/#2-create-and-instance-of-the-model-class-and-specify-global-model-units","title":"2) Create and instance of the Model class and specify global model units.","text":"<pre><code>Model().with_units(concentration=\"mg/L\", time=\"h\", volume=\"L\")\n</code></pre>"},{"location":"model-specification/#3-specify-model-parameters","title":"3) Specify model parameters","text":"<pre><code>with parameters():\n    # drug dose\n    drug_dose = (100.0, \"mg\")\n    # Compartment volumes\n    V_CENTRAL = (10.0, \"L\")\n    V_PERIPHERAL = (1.0, \"L\")\n    # drug distribution rate constants\n    k_CP = (1e-1, \"1/s\")\n    k_PC = (1e-3, \"1/s\")\n    # receptor density\n    receptor_0 = (100.0, \"ug/L\")\n    # receptor binding rate constants\n    k_f = (1.0, \"L/(ug * s)\")\n    k_r = (1e-3, \"1/s\")\n</code></pre>"},{"location":"model-specification/#4-define-any-expressions","title":"4) Define any expressions","text":"<pre><code>with expressions():\n    # Initial drug concentration - bolus dose\n    drug_0 = drug_dose / V_CENTRAL\n</code></pre>"},{"location":"model-specification/#5-specify-the-model-compartments","title":"5) Specify the model compartments","text":"<pre><code>with compartments():\n    CENTRAL = V_CENTRAL\n    PERIPHERAL = V_PERIPHERAL\n</code></pre>"},{"location":"model-specification/#6-define-any-monomer-species","title":"6) Define any monomer species","text":"<pre><code>with monomers():\n    drug = (['b'], None, DRUG.AGONIST)\n    receptor = (['b'], None, PROTEIN.RECEPTOR)\n</code></pre>"},{"location":"model-specification/#7-specify-initial-conditions","title":"7) Specify initial conditions","text":"<pre><code>with initials():\n    drug(b=None)**CENTRAL &lt;&lt; drug_0\n    receptor(b=None)**PERIPHERAL &lt;&lt; receptor_0\n</code></pre>"},{"location":"model-specification/#8-define-reaction-rules","title":"8) Define reaction rules","text":"<pre><code>with rules():\n    # Distribution\n    drug_distribution = (drug(b=None)**CENTRAL | drug(b=None)**PERIPHERAL, k_CP, k_PC)\n    # Receptor binding\n    receptor_binding = (drug(b=None)**PERIPHERAL + receptor(b=None)**PERIPHERAL | drug(b=1)**PERIPHERAL % receptor(b=1)**PERIPHERAL, k_f, k_r)\n</code></pre>"},{"location":"model-specification/#9-assign-observables","title":"9) Assign observables","text":"<pre><code>with observables():\n    drug(b=1)**PERIPHERAL % receptor(b=1)**PERIPHERAL &gt; \"OccupiedReceptor\"\n</code></pre>"},{"location":"model-specification/#10-assign-model-metadata-and-tracker-optional","title":"10) Assign model metadata and tracker (optional)","text":"<pre><code>__version__ = 0.1.0\n__author__ = \"Jane Doe\"\nModelMetadataTracker(__version__, author=__author__)\n</code></pre> <p>Info</p> <p>Learn more about the metadata tracker</p>"},{"location":"model-specification/#11-initialize-model-checker-optional","title":"11) Initialize model checker (optional)","text":"<pre><code>ModelChecker()\n</code></pre> <p>Info</p> <p>Learn more about the model checker</p>"},{"location":"model-specification/#12-include-a-mermaid-diagram-generator-optional","title":"12) Include a mermaid diagram generator (optional)","text":"<pre><code>ModelMermaidDiagrammer()\n</code></pre> <p>Info</p> <p>Learn more about the diagram generator</p>"},{"location":"model-specification/#full-example-model","title":"Full example model","text":"<p>pkro_model.py</p> <pre><code>from qspy import *\n\nwith parameters():\n    # drug dose\n    drug_dose = (100.0, \"mg\")\n    # Compartment volumes\n    V_CENTRAL = (10.0, \"L\")\n    V_PERIPHERAL = (1.0, \"L\")\n    # drug distribution rate constants\n    k_CP = (1e-1, \"1/s\")\n    k_PC = (1e-3, \"1/s\")\n    # receptor density\n    receptor_0 = (100.0, \"ug/L\")\n    # receptor binding rate constants\n    k_f = (1.0, \"L/(ug * s)\")\n    k_r = (1e-3, \"1/s\")\n\nwith expressions():\n    # Initial drug concentration - bolus dose\n    drug_0 = drug_dose / V_CENTRAL\n\nwith compartments():\n    CENTRAL = V_CENTRAL\n    PERIPHERAL = V_PERIPHERAL\n\nwith monomers():\n    drug = (['b'], None, DRUG.AGONIST)\n    receptor = (['b'], None, PROTEIN.RECEPTOR)\n\nwith initials():\n    drug(b=None)**CENTRAL &lt;&lt; drug_0\n    receptor(b=None)**PERIPHERAL &lt;&lt; receptor_0\n\nwith rules():\n    # Distribution\n    drug_distribution = (drug(b=None)**CENTRAL | drug(b=None)**PERIPHERAL, k_CP, k_PC)\n    # Receptor binding\n    receptor_binding = (drug(b=None)**PERIPHERAL + receptor(b=None)**PERIPHERAL | drug(b=1)**PERIPHERAL % receptor(b=1)**PERIPHERAL, k_f, k_r)\n\nwith observables():\n    drug(b=1)**PERIPHERAL % receptor(b=1)**PERIPHERAL &gt; \"OccupiedReceptor\"\n\n__version__ = 0.1.0\n__author__ = \"Jane Doe\"\nModelMetadataTracker(__version__, author=__author__)\nModelMermaidDiagrammer()\nModelChecker()\n</code></pre>"},{"location":"model-summary-generator/","title":"Model Summary Generator in QSPy","text":"<p>QSPy provides a convenient method for generating human-readable summaries of your model using the <code>Model.markdown_summary</code> function. This feature helps you document, review, and share the structure and key properties of your quantitative systems pharmacology (QSP) models.</p>"},{"location":"model-summary-generator/#what-is-modelmarkdown_summary","title":"What is <code>Model.markdown_summary</code>?","text":"<p>The <code>markdown_summary</code> method is available on QSPy <code>Model</code> objects. It generates a Markdown summary file that includes:</p> <ul> <li>Model metadata (name, version, author, timestamp, hash)</li> <li>Monomer definitions (including sites, states, and functional tags)</li> <li>Parameters and their units</li> <li>Initial conditions</li> <li>Rules</li> <li>Observables</li> <li>(Optionally) a model diagram if the <code>ModelMermaidDiagrammer</code> object is included in the model definition.</li> </ul> <p>This summary is useful for documentation, collaboration, and reproducibility.</p>"},{"location":"model-summary-generator/#usage","title":"Usage","text":""},{"location":"model-summary-generator/#basic-example","title":"Basic Example","text":"<pre><code>from qspy.core import Model\n\n# Build your model here...\n\nmodel = Model().with_units(...)\n# ... define monomers, parameters, rules, etc.\n\n# Generate a summary file (default location: SUMMARY_DIR)\nmodel.markdown_summary()\n</code></pre>"},{"location":"model-summary-generator/#custom-output-path","title":"Custom Output Path","text":"<p>You can specify a custom output path for the summary file:</p> <pre><code>model.markdown_summary(path=\"my_model_summary.md\")\n</code></pre>"},{"location":"model-summary-generator/#including-a-model-diagram","title":"Including a Model Diagram","text":"<p>If you include an instance of <code>ModelMermaidDiagrammer</code> in the model definition then  the corresponding diagram will be included in the summary:</p> <pre><code>model.markdown_summary(include_diagram=True)\n</code></pre>"},{"location":"model-summary-generator/#example-output","title":"Example Output","text":"<p>A generated summary file (Markdown) will look like:</p> <pre><code># QSPy Model Summary: `MyModel`\n\n**Model name**: `MyModel`  \n**Hash**: `abcd1234`  \n**Version**: 1.0.0  \n**Author**: Alice  \n**Executed by**: alice  \n**Timestamp**: 2025-07-02T12:34:56\n\n## \ud83d\uddbc\ufe0f Model Diagram\n\n&lt;!-- (Diagram would appear here if generated) --&gt;\n\n## Core Units\n| Quantity      | Unit |\n|-------------- |------|\n| Concentration | nM   |\n| Time          | h    |\n| Volume        | L    |\n\n## Model Component Counts\n| Component Type      | Count |\n|---------------------|-------|\n| Monomers            | 2     |\n| Parameters          | 2     |\n| Expressions         | 0     |\n| Compartments        | 0     |\n| Rules               | 1     |\n| Initial Conditions  | 2     |\n| Observables         | 2     |\n\n## Compartments\n| Name  | Size |\n|-------|------|\n| _None_ | _N/A_ |\n\n## Monomers\n| Name | Sites   | States                      | Functional Tag      |\n|------|---------|-----------------------------|---------------------|\n| A    | ['b']   | {'b': ['u', 'p']}           | protein::ligand     |\n| B    | []      | {}                          | protein::receptor   |\n\n## Parameters\n| Name | Value | Units |\n|------|-------|-------|\n| k1   | 1.0   | 1/min |\n| k2   | 0.5   | 1/min |\n\n## Expressions\n| Name | Expression |\n|------|------------|\n| _None_ | _N/A_    |\n\n## Initial Conditions\n| Species   | Value | Units |\n|-----------|-------|-------|\n| A(b=None) | 100   | nM    |\n| B()       | 200   | nM    |\n\n## Rules\n| Name | Rule Expression                        | k_f | k_r  | reversible |\n|------|----------------------------------------|-----|------|------------|\n| bind | `A(b=None) + B() &gt;&gt; A(b=1) % B()`      | k1  | None | False      |\n\n## Observables\n| Name     | Reaction Pattern |\n|----------|------------------|\n| A_total  | `A()`            |\n| B_total  | `B()`            |\n</code></pre>"},{"location":"model-summary-generator/#why-use-model-summaries","title":"Why Use Model Summaries?","text":"<ul> <li>Documentation: Quickly generate a comprehensive overview of your model for reports or publications.</li> <li>Collaboration: Share model structure and assumptions with colleagues.</li> <li>Reproducibility: Archive model state and metadata alongside simulation results.</li> </ul>"},{"location":"model-summary-generator/#see-also","title":"See Also","text":"<ul> <li>Model Metadata Tracking</li> </ul>"},{"location":"outputs-logs/","title":"QSPy Outputs and Logs","text":"<p>QSPy automatically generates a variety of outputs and logs to help you track, audit, and reproduce your modeling work. By default, these files are stored in a hidden <code>.qspy</code> folder in your project directory.</p>"},{"location":"outputs-logs/#what-is-in-the-qspy-folder","title":"What is in the <code>.qspy</code> Folder?","text":"<p>The <code>.qspy</code> folder is created automatically when you run QSPy code. It contains:</p> <ul> <li>Model summaries: Markdown files summarizing model structure, parameters, and metadata (output from the <code>Model.markdown_summary</code> function)</li> <li>Model diagrams: Mermaid or image files visualizing model architecture (if enabled by using the <code>ModelMermaidDiagrammer</code>).</li> <li>Run logs: Detailed logs of model construction, macro usage, and simulation runs.</li> <li>Audit trails: Metadata and hashes for reproducibility and version tracking (if enabled by using the <code>ModelMetadataTracker</code>).</li> </ul> <p>This folder is intended to be a central location for all QSPy-generated artifacts, making it easy to review your modeling workflow and share results.</p>"},{"location":"outputs-logs/#example-contents","title":"Example Contents","text":"<pre><code>.qspy/\n\u251c\u2500\u2500 model_summary.md\n\u251c\u2500\u2500 model_diagram.mmd\n\u251c\u2500\u2500 logs/\n\u251c\u2500\u2500\u2500|\u2500\u2500\u2500\u2500 qspy.log\n\u251c\u2500\u2500 metadata/\n\u251c\u2500\u2500\u2500|\u2500\u2500\u2500\u2500 model-name__author__short-hash__time.toml\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"outputs-logs/#changing-the-output-location","title":"Changing the Output Location","text":"<p>By default, QSPy writes all outputs and logs to <code>.qspy</code> in the current working directory. You can change this location using the <code>qspy.config</code> module.</p> <p>Change the output directory</p> <pre><code>import qspy.config\n\n# Set a new output directory for QSPy logs and artifacts\nqspy.config.set_output_dir(\"my_outputs/qspy_artifacts\")\n</code></pre> <p>This will update <code>qspy.config.OUTPUT_DIR</code>, and all new logs and outputs will be written to the specified folder.</p>"},{"location":"outputs-logs/#tips","title":"Tips","text":"<ul> <li>Version control: You may want to add <code>.qspy/</code> to your <code>.gitignore</code> if you do not wish to track logs and outputs in version control.</li> <li>Reproducibility: The logs and metadata in <code>.qspy</code> are useful for reproducing results and tracking model changes over time.</li> <li>Cleanup: You can safely delete the <code>.qspy</code> folder if you want to clear outputs; it will be recreated as needed.</li> </ul>"},{"location":"outputs-logs/#see-also","title":"See Also","text":"<ul> <li>Model Summary Generator</li> <li>Model Diagram Generator</li> <li>Metadata Tracking</li> </ul>"},{"location":"qsp-modeling/","title":"What is QSP Modeling?","text":"<p>Quantitative systems pharmacology (QSP) integrates traditional pharmacological modeling (e.g., PK/PD modeling) and mechanistic systems biology modeling (e.g., biochemical network modeling) to better understand how drugs interact with biological targets, affect biochemical pathways, and how biological systems and diseases respond to drug intervention. The resulting mathematical models can thus integrate knowledge and data on drug pharmacokinetics, drug mechanism-of-action (MoA), biological pathways, and disease processes to better understand drug effects and treatment potential. </p> <p>QSP models are particularly useful for in silico hypothesis testing and prediction, supporting drug discovery and development decisions in areas such as target selection, dose optimization, and precision medicine.</p> <p>The following diagram gives a reasonable overview of QSP models and an associated modeling workflow:</p> <p> [Figure 1 of Helmlinger et al. 2019, Quantitative Systems Pharmacology: An Exemplar Model\u2010Building Workflow With Applications in Cardiovascular, Metabolic, and Oncology Drug Development, CPT Pharmacometrics Syst. Pharmacol., 8: 380-395 | reproduced here without modification under Creative Commons License]</p> <p>This diagram shows a systems biology modeling workflow, which is also highly applicable to QSP modeling:</p> <p> [Figure 2 of Guimera et al., Systems modelling ageing: from single senescent cells to simple multi-cellular models, Essays Biochem (2017) 61 (3): 369\u2013377. | reproduced here without modification under CC BY License]</p>"},{"location":"qsp-modeling/#learn-more","title":"Learn More","text":"<p>External Resources on QSP:</p> <ul> <li>What Is Quantitative Systems Pharmacology? | MathWorks Discovery Page</li> <li>Benefits &amp; Uses of QSP in Drug Development | Allucent Blog Post</li> <li>Mathematical Sandbox: How Quantitative Systems Pharmacology Steers Safer, Faster Drug Development | Pfizer News Article</li> <li>Quantitative Systems Pharmacology (QSP): Past, Present and Future | Certara YouTube Video</li> <li>History and Future Perspectives on the Discipline of Quantitative Systems Pharmacology Modeling and Its Applications | Academic Review Article - Open Access</li> </ul>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#qspy.core","title":"<code>qspy.core</code>","text":""},{"location":"reference/#qspy.core--qspy-core-model-extensions-and-utilities","title":"QSPy Core Model Extensions and Utilities","text":"<p>This module extends the PySB modeling framework with QSPy-specific features for quantitative systems pharmacology (QSP) workflows. It provides enhanced Model and Monomer classes, operator overloads for semantic annotation, and utilities for metadata, logging, and summary/diagram generation.</p> <p>Classes:</p> Name Description <code>Model : QSPy extension of the PySB Model class with metadata, summary, and diagram support.</code> <code>Monomer : QSPy extension of the PySB Monomer class with functional tag support.</code> <p>Functions:</p> Name Description <code>mp_lshift : Overloads '&lt;&lt;' for MonomerPattern/ComplexPattern to create Initial objects.</code> <code>mp_invert : Overloads '~' for MonomerPattern/ComplexPattern to create Observables with auto-naming.</code> <code>mp_gt : Overloads '&gt;' for MonomerPattern/ComplexPattern to create Observables with custom names.</code> <code>_make_mono_string : Utility to generate string names for MonomerPatterns.</code> <code>_make_complex_string : Utility to generate string names for ComplexPatterns.</code> Operator Overloads <ul> <li>MonomerPattern/ComplexPattern &lt;&lt; value : Create Initial objects.</li> <li>~MonomerPattern/ComplexPattern : Create Observable objects with auto-generated names.</li> <li>MonomerPattern/ComplexPattern &gt; \"name\" : Create Observable objects with custom names.</li> <li>Monomer @ tag : Attach a functional tag to a Monomer.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from qspy.core import Model, Monomer\n&gt;&gt;&gt; m = Monomer(\"A\", [\"b\"])\n&gt;&gt;&gt; m @ PROTEIN.LIGAND\n&gt;&gt;&gt; model = Model()\n&gt;&gt;&gt; model.with_units(\"nM\", \"min\", \"uL\")\n&gt;&gt;&gt; ~m(b=None)\nObservable('A_u', m(b=None))\n</code></pre> <pre><code>&gt;&gt;&gt; m(b=None) &lt;&lt; 100\nInitial(m(b=None), 100)\n</code></pre>"},{"location":"reference/#qspy.core.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>Model</code></p> <p>QSPy extension of the PySB Model class.</p> <p>Adds QSPy-specific utilities, metadata handling, and summary/diagram generation to the standard PySB Model. Supports custom units, logging, and functional tagging.</p> <p>Methods:</p> Name Description <code>with_units</code> <p>Set simulation units for concentration, time, and volume.</p> <code>component_names</code> <p>List of component names in the model.</p> <code>qspy_metadata</code> <p>Dictionary of QSPy metadata for the model.</p> <code>summarize</code> <p>Generate a Markdown summary of the model and optionally a diagram.</p> Source code in <code>qspy\\core.py</code> <pre><code>class Model(Model):\n    \"\"\"\n    QSPy extension of the PySB Model class.\n\n    Adds QSPy-specific utilities, metadata handling, and summary/diagram generation\n    to the standard PySB Model. Supports custom units, logging, and functional tagging.\n\n    Methods\n    -------\n    with_units(concentration, time, volume)\n        Set simulation units for concentration, time, and volume.\n    component_names\n        List of component names in the model.\n    qspy_metadata\n        Dictionary of QSPy metadata for the model.\n    summarize(path, include_diagram)\n        Generate a Markdown summary of the model and optionally a diagram.\n    \"\"\"\n\n    @log_event(log_args=True, static_method=True)\n    @staticmethod\n    def with_units(concentration: str = \"mg/L\", time: str = \"h\", volume: str = \"L\"):\n        \"\"\"\n        Set simulation units for the model.\n\n        Parameters\n        ----------\n        concentration : str, optional\n            Concentration units (default \"mg/L\").\n        time : str, optional\n            Time units (default \"h\").\n        volume : str, optional\n            Volume units (default \"L\").\n        \"\"\"\n        ensure_qspy_logging()\n        SimulationUnits(concentration, time, volume)\n        return\n\n    @property\n    def component_names(self):\n        \"\"\"\n        List the names of all components in the model.\n\n        Returns\n        -------\n        list of str\n            Names of model components.\n        \"\"\"\n        return [component.name for component in self.components]\n\n    @property\n    def qspy_metadata(self):\n        \"\"\"\n        Return QSPy metadata dictionary for the model.\n\n        Returns\n        -------\n        dict\n            Metadata dictionary if available, else empty dict.\n        \"\"\"\n        if hasattr(self, \"qspy_metadata_tracker\"):\n            return self.qspy_metadata_tracker.metadata\n        else:\n            return {}\n\n    @log_event(log_args=True)\n    def markdown_summary(self, path=SUMMARY_DIR, include_diagram=True):\n        \"\"\"\n        Generate a Markdown summary of the model and optionally a diagram.\n\n        Parameters\n        ----------\n        path : str or Path, optional\n            Output path for the summary file (default: SUMMARY_DIR).\n        include_diagram : bool, optional\n            Whether to include a model diagram if SBMLDiagrams is available (default: True).\n\n        Returns\n        -------\n        None\n        \"\"\"\n        lines = []\n        lines.append(f\"# QSPy Model Summary: `{self.name}`\\n\")\n\n        metadata = self.qspy_metadata\n        lines.append(f\"**Model name**: `{self.name}` \\n\")\n        lines.append(f\"**Hash**: \\n`{metadata.get('hash', 'N/A')}` \\n\")\n        lines.append(f\"**Version**: {metadata.get('version', 'N/A')} \\n\")\n        lines.append(f\"**Author**: {metadata.get('author', 'N/A')} \\n\")\n        lines.append(f\"**Executed by**: {metadata.get('current_user', 'N/A')} \\n\")\n        lines.append(\n            f\"**Timestamp**: {metadata.get('created_at', datetime.now().isoformat())}\\n\"\n        )\n\n        if include_diagram and hasattr(self, \"mermaid_diagram\"):\n            diagram_md = self.mermaid_diagram.markdown_block\n            lines.append(\"## \ud83d\uddbc\ufe0f Model Diagram\\n\")\n            lines.append(f\"{diagram_md}\\n\")\n\n        # Core units table\n        lines.append(\"## Core Units\\n| Quantity | Unit |\")\n        lines.append(\"|-----------|------|\")\n        units = getattr(self, \"simulation_units\", None)\n        if units:\n            lines.append(f\"| Concentration | {units.concentration} |\")\n            lines.append(f\"| Time         | {units.time} |\")\n            lines.append(f\"| Volume       | {units.volume} |\")\n        else:\n            lines.append(\"No core model units defined.\")\n            lines.append(\"    They can added with the `Model.with_units` method.\")\n\n        # Component counts table\n        lines.append(\"## Numbers of Model Component\\n| Component Type | Count |\")\n        lines.append(\"|---------------|-------|\")\n        lines += [\n            f\"| Monomers | {len(getattr(self, 'monomers', []))} |\",\n            f\"| Parameters | {len(getattr(self, 'parameters', []))} |\",\n            f\"| Expressions | {len(getattr(self, 'expressions', []))} |\",\n            f\"| Compartments | {len(getattr(self, 'compartments', []))} |\",\n            f\"| Rules | {len(getattr(self, 'rules', []))} |\",\n            f\"| Initial Conditions | {len(getattr(self, 'initial_conditions', []))} |\",\n            f\"| Observables | {len(getattr(self, 'observables', []))} |\",\n        ]\n\n        # Compartments table\n        lines.append(\"\\n## Compartments\\n| Name | Size |\")\n        lines.append(\"|------|------|\")\n        lines += [\n            f\"| {cpt.name} | {cpt.size.name if hasattr(cpt.size, 'name') else str(cpt.size)} |\"\n            for cpt in getattr(self, \"compartments\", [])\n        ] or [\"| _None_ | _N/A_ |\"]\n\n        # Monomers table\n        lines.append(\"## Monomers\\n| Name | Sites | States | Functional Tag |\")\n        lines.append(\"|------|-------|--------|---------------|\")\n        lines += [\n            f\"| {m.name} | {m.sites} | {m.site_states} | {getattr(m.functional_tag, 'value', m.functional_tag)} |\"\n            for m in self.monomers\n        ] or [\"| _None_ | _N/A_ | _N/A_ | _N/A_ |\"]\n\n        # Parameters table\n        lines.append(\"\\n## Parameters\\n| Name | Value | Units |\")\n        lines.append(\"|------|--------|--------|\")\n        lines += [\n            f\"| {p.name} | {p.value} | {p.unit.to_string()} |\" for p in self.parameters\n        ] or [\"| _None_ | _N/A_ |\"]\n\n        # Expressions table\n        lines.append(\"\\n## Expressions\\n| Name | Expression |\")\n        lines.append(\"|------|------------|\")\n        lines += [\n            f\"| {e.name} | `{e.expr}` |\" for e in getattr(self, \"expressions\", [])\n        ] or [\"| _None_ | _N/A_ |\"]\n\n        # Initial Conditions table\n        lines.append(\"\\n## Initial Conditions\\n| Species | Value | Units |\")\n        lines.append(\"|---------|--------|--------|\")\n        lines += [\n            f\"| {str(ic[0])} | {ic[1].value if isinstance(ic[1], Parameter) else ic[1].get_value():.2f} | {ic[1].units.value}\"\n            for ic in self.initial_conditions\n        ] or [\"| _None_ | _N/A_ |\"]\n\n        def _sanitize_rule_expression(expr):\n            \"\"\"\n            Sanitize rule expression for Markdown rendering.\n            Replaces ' | ' with ' \\| ' to avoid Markdown table formatting issues.\n            \"\"\"\n            return repr(expr).replace(\" | \", \" \\| \")\n        # Rules table\n        lines.append(\"\\n## Rules\\n| Name | Rule Expression | k_f | k_r | reversible |\")\n        lines.append(\"|------|-----------------|-----|-----|------------|\")\n        lines += [\n            f\"| {r.name} | `{_sanitize_rule_expression(r.rule_expression)}` | {r.rate_forward.name} | {r.rate_reverse.name if r.rate_reverse is not None else 'None'} | {r.is_reversible} |\"\n            for r in self.rules\n        ] or [\"| _None_ | _N/A_ | _N/A_ | _N/A_ | _N/A_ |\"]\n\n        # Observables table\n        lines.append(\"\\n## Observables\\n| Name | Reaction Pattern |\")\n        lines.append(\"|------|------------------|\")\n        lines += [\n            f\"| {o.name} | `{o.reaction_pattern}` |\" for o in self.observables\n        ] or [\"| _None_ | _N/A_ |\"]\n\n        path = Path(path)\n        path.parent.mkdir(parents=True, exist_ok=True)\n        with open(path, \"w\", encoding=\"utf-8\") as f:\n            f.write(\"\\n\".join(lines))\n</code></pre>"},{"location":"reference/#qspy.core.Model.component_names","title":"<code>component_names</code>  <code>property</code>","text":"<p>List the names of all components in the model.</p> <p>Returns:</p> Type Description <code>list of str</code> <p>Names of model components.</p>"},{"location":"reference/#qspy.core.Model.qspy_metadata","title":"<code>qspy_metadata</code>  <code>property</code>","text":"<p>Return QSPy metadata dictionary for the model.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Metadata dictionary if available, else empty dict.</p>"},{"location":"reference/#qspy.core.Model.markdown_summary","title":"<code>markdown_summary(path=SUMMARY_DIR, include_diagram=True)</code>","text":"<p>Generate a Markdown summary of the model and optionally a diagram.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>Output path for the summary file (default: SUMMARY_DIR).</p> <code>SUMMARY_DIR</code> <code>include_diagram</code> <code>bool</code> <p>Whether to include a model diagram if SBMLDiagrams is available (default: True).</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>qspy\\core.py</code> <pre><code>@log_event(log_args=True)\ndef markdown_summary(self, path=SUMMARY_DIR, include_diagram=True):\n    \"\"\"\n    Generate a Markdown summary of the model and optionally a diagram.\n\n    Parameters\n    ----------\n    path : str or Path, optional\n        Output path for the summary file (default: SUMMARY_DIR).\n    include_diagram : bool, optional\n        Whether to include a model diagram if SBMLDiagrams is available (default: True).\n\n    Returns\n    -------\n    None\n    \"\"\"\n    lines = []\n    lines.append(f\"# QSPy Model Summary: `{self.name}`\\n\")\n\n    metadata = self.qspy_metadata\n    lines.append(f\"**Model name**: `{self.name}` \\n\")\n    lines.append(f\"**Hash**: \\n`{metadata.get('hash', 'N/A')}` \\n\")\n    lines.append(f\"**Version**: {metadata.get('version', 'N/A')} \\n\")\n    lines.append(f\"**Author**: {metadata.get('author', 'N/A')} \\n\")\n    lines.append(f\"**Executed by**: {metadata.get('current_user', 'N/A')} \\n\")\n    lines.append(\n        f\"**Timestamp**: {metadata.get('created_at', datetime.now().isoformat())}\\n\"\n    )\n\n    if include_diagram and hasattr(self, \"mermaid_diagram\"):\n        diagram_md = self.mermaid_diagram.markdown_block\n        lines.append(\"## \ud83d\uddbc\ufe0f Model Diagram\\n\")\n        lines.append(f\"{diagram_md}\\n\")\n\n    # Core units table\n    lines.append(\"## Core Units\\n| Quantity | Unit |\")\n    lines.append(\"|-----------|------|\")\n    units = getattr(self, \"simulation_units\", None)\n    if units:\n        lines.append(f\"| Concentration | {units.concentration} |\")\n        lines.append(f\"| Time         | {units.time} |\")\n        lines.append(f\"| Volume       | {units.volume} |\")\n    else:\n        lines.append(\"No core model units defined.\")\n        lines.append(\"    They can added with the `Model.with_units` method.\")\n\n    # Component counts table\n    lines.append(\"## Numbers of Model Component\\n| Component Type | Count |\")\n    lines.append(\"|---------------|-------|\")\n    lines += [\n        f\"| Monomers | {len(getattr(self, 'monomers', []))} |\",\n        f\"| Parameters | {len(getattr(self, 'parameters', []))} |\",\n        f\"| Expressions | {len(getattr(self, 'expressions', []))} |\",\n        f\"| Compartments | {len(getattr(self, 'compartments', []))} |\",\n        f\"| Rules | {len(getattr(self, 'rules', []))} |\",\n        f\"| Initial Conditions | {len(getattr(self, 'initial_conditions', []))} |\",\n        f\"| Observables | {len(getattr(self, 'observables', []))} |\",\n    ]\n\n    # Compartments table\n    lines.append(\"\\n## Compartments\\n| Name | Size |\")\n    lines.append(\"|------|------|\")\n    lines += [\n        f\"| {cpt.name} | {cpt.size.name if hasattr(cpt.size, 'name') else str(cpt.size)} |\"\n        for cpt in getattr(self, \"compartments\", [])\n    ] or [\"| _None_ | _N/A_ |\"]\n\n    # Monomers table\n    lines.append(\"## Monomers\\n| Name | Sites | States | Functional Tag |\")\n    lines.append(\"|------|-------|--------|---------------|\")\n    lines += [\n        f\"| {m.name} | {m.sites} | {m.site_states} | {getattr(m.functional_tag, 'value', m.functional_tag)} |\"\n        for m in self.monomers\n    ] or [\"| _None_ | _N/A_ | _N/A_ | _N/A_ |\"]\n\n    # Parameters table\n    lines.append(\"\\n## Parameters\\n| Name | Value | Units |\")\n    lines.append(\"|------|--------|--------|\")\n    lines += [\n        f\"| {p.name} | {p.value} | {p.unit.to_string()} |\" for p in self.parameters\n    ] or [\"| _None_ | _N/A_ |\"]\n\n    # Expressions table\n    lines.append(\"\\n## Expressions\\n| Name | Expression |\")\n    lines.append(\"|------|------------|\")\n    lines += [\n        f\"| {e.name} | `{e.expr}` |\" for e in getattr(self, \"expressions\", [])\n    ] or [\"| _None_ | _N/A_ |\"]\n\n    # Initial Conditions table\n    lines.append(\"\\n## Initial Conditions\\n| Species | Value | Units |\")\n    lines.append(\"|---------|--------|--------|\")\n    lines += [\n        f\"| {str(ic[0])} | {ic[1].value if isinstance(ic[1], Parameter) else ic[1].get_value():.2f} | {ic[1].units.value}\"\n        for ic in self.initial_conditions\n    ] or [\"| _None_ | _N/A_ |\"]\n\n    def _sanitize_rule_expression(expr):\n        \"\"\"\n        Sanitize rule expression for Markdown rendering.\n        Replaces ' | ' with ' \\| ' to avoid Markdown table formatting issues.\n        \"\"\"\n        return repr(expr).replace(\" | \", \" \\| \")\n    # Rules table\n    lines.append(\"\\n## Rules\\n| Name | Rule Expression | k_f | k_r | reversible |\")\n    lines.append(\"|------|-----------------|-----|-----|------------|\")\n    lines += [\n        f\"| {r.name} | `{_sanitize_rule_expression(r.rule_expression)}` | {r.rate_forward.name} | {r.rate_reverse.name if r.rate_reverse is not None else 'None'} | {r.is_reversible} |\"\n        for r in self.rules\n    ] or [\"| _None_ | _N/A_ | _N/A_ | _N/A_ | _N/A_ |\"]\n\n    # Observables table\n    lines.append(\"\\n## Observables\\n| Name | Reaction Pattern |\")\n    lines.append(\"|------|------------------|\")\n    lines += [\n        f\"| {o.name} | `{o.reaction_pattern}` |\" for o in self.observables\n    ] or [\"| _None_ | _N/A_ |\"]\n\n    path = Path(path)\n    path.parent.mkdir(parents=True, exist_ok=True)\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        f.write(\"\\n\".join(lines))\n</code></pre>"},{"location":"reference/#qspy.core.Model.with_units","title":"<code>with_units(concentration='mg/L', time='h', volume='L')</code>  <code>staticmethod</code>","text":"<p>Set simulation units for the model.</p> <p>Parameters:</p> Name Type Description Default <code>concentration</code> <code>str</code> <p>Concentration units (default \"mg/L\").</p> <code>'mg/L'</code> <code>time</code> <code>str</code> <p>Time units (default \"h\").</p> <code>'h'</code> <code>volume</code> <code>str</code> <p>Volume units (default \"L\").</p> <code>'L'</code> Source code in <code>qspy\\core.py</code> <pre><code>@log_event(log_args=True, static_method=True)\n@staticmethod\ndef with_units(concentration: str = \"mg/L\", time: str = \"h\", volume: str = \"L\"):\n    \"\"\"\n    Set simulation units for the model.\n\n    Parameters\n    ----------\n    concentration : str, optional\n        Concentration units (default \"mg/L\").\n    time : str, optional\n        Time units (default \"h\").\n    volume : str, optional\n        Volume units (default \"L\").\n    \"\"\"\n    ensure_qspy_logging()\n    SimulationUnits(concentration, time, volume)\n    return\n</code></pre>"},{"location":"reference/#qspy.core.Monomer","title":"<code>Monomer</code>","text":"<p>               Bases: <code>Monomer</code></p> <p>QSPy extension of the PySB Monomer class.</p> <p>Adds support for functional tags and operator overloading for semantic annotation.</p> <p>Methods:</p> Name Description <code>__matmul__</code> <p>Attach a functional tag to the monomer using the '@' operator.</p> <code>__imatmul__</code> <p>Attach a functional tag to the monomer in-place using the '@=' operator.</p> <code>__repr__</code> <p>String representation including the functional tag if present.</p> Source code in <code>qspy\\core.py</code> <pre><code>class Monomer(Monomer):\n    \"\"\"\n    QSPy extension of the PySB Monomer class.\n\n    Adds support for functional tags and operator overloading for semantic annotation.\n\n    Methods\n    -------\n    __matmul__(other)\n        Attach a functional tag to the monomer using the '@' operator.\n    __imatmul__(other)\n        Attach a functional tag to the monomer in-place using the '@=' operator.\n    __repr__()\n        String representation including the functional tag if present.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Initialize a Monomer with optional functional tag.\n\n        Parameters\n        ----------\n        *args, **kwargs\n            Arguments passed to the PySB Monomer constructor.\n        \"\"\"\n        self.functional_tag = FunctionalTag(\n            \"None\", \"None\"\n        )  # Default to no functional tag\n        super().__init__(*args, **kwargs)\n        return\n\n    def __matmul__(self, other: Enum):\n        \"\"\"\n        Attach a functional tag to the monomer using the '@' operator.\n\n        Parameters\n        ----------\n        other : Enum\n            Enum member representing the functional tag.\n\n        Returns\n        -------\n        Monomer\n            The monomer instance with the functional tag set.\n        \"\"\"\n        if isinstance(other, Enum):\n            ftag_str = other.value\n            ftag = FunctionalTag(*FunctionalTag.parse(ftag_str))\n            setattr(self, \"functional_tag\", ftag)\n        return self\n\n    def __imatmul__(self, other: Enum):\n        \"\"\"\n        Attach a functional tag to the monomer in-place using the '@=' operator.\n\n        Parameters\n        ----------\n        other : Enum\n            Enum member representing the functional tag.\n\n        Returns\n        -------\n        Monomer\n            The monomer instance with the functional tag set.\n        \"\"\"\n        if isinstance(other, Enum):\n            ftag_str = other.value\n            ftag = FunctionalTag(*FunctionalTag.parse(ftag_str))\n            setattr(self, \"functional_tag\", ftag)\n        return self\n\n    def __repr__(self):\n        \"\"\"\n        Return a string representation of the monomer, including the functional tag if present.\n\n        Returns\n        -------\n        str\n            String representation of the monomer.\n        \"\"\"\n        if self.functional_tag is None:\n            return super().__repr__()\n        else:\n            base_repr = super().__repr__()\n            return f\"{base_repr} @ {self.functional_tag.value}\"\n\n    def __pow__(self, compartment: Compartment):\n        \"\"\"\n        Overload the '**' operator to allow monomers to be passed with a compartment.\n\n        This is a shortcut for creating a MonomerPattern with a compartment:\n          i.e., `monomer ** compartment` is equivalent to `monomer() ** compartment`.\n\n\n        Parameters\n        ----------\n        compartment : Compartment\n            The compartment in which the monomer pattern resides.\n\n        Returns\n        -------\n        MonomerPattern\n            A MonomerPattern from calling the monomer with the compartment.\n        \"\"\"\n        if not isinstance(compartment, Compartment):\n            raise TypeError(\"Compartment must be an instance of Compartment\")\n        return self() ** compartment\n</code></pre>"},{"location":"reference/#qspy.core.Monomer.__imatmul__","title":"<code>__imatmul__(other)</code>","text":"<p>Attach a functional tag to the monomer in-place using the '@=' operator.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Enum</code> <p>Enum member representing the functional tag.</p> required <p>Returns:</p> Type Description <code>Monomer</code> <p>The monomer instance with the functional tag set.</p> Source code in <code>qspy\\core.py</code> <pre><code>def __imatmul__(self, other: Enum):\n    \"\"\"\n    Attach a functional tag to the monomer in-place using the '@=' operator.\n\n    Parameters\n    ----------\n    other : Enum\n        Enum member representing the functional tag.\n\n    Returns\n    -------\n    Monomer\n        The monomer instance with the functional tag set.\n    \"\"\"\n    if isinstance(other, Enum):\n        ftag_str = other.value\n        ftag = FunctionalTag(*FunctionalTag.parse(ftag_str))\n        setattr(self, \"functional_tag\", ftag)\n    return self\n</code></pre>"},{"location":"reference/#qspy.core.Monomer.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize a Monomer with optional functional tag.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Arguments passed to the PySB Monomer constructor.</p> <code>()</code> <code>**kwargs</code> <p>Arguments passed to the PySB Monomer constructor.</p> <code>()</code> Source code in <code>qspy\\core.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"\n    Initialize a Monomer with optional functional tag.\n\n    Parameters\n    ----------\n    *args, **kwargs\n        Arguments passed to the PySB Monomer constructor.\n    \"\"\"\n    self.functional_tag = FunctionalTag(\n        \"None\", \"None\"\n    )  # Default to no functional tag\n    super().__init__(*args, **kwargs)\n    return\n</code></pre>"},{"location":"reference/#qspy.core.Monomer.__matmul__","title":"<code>__matmul__(other)</code>","text":"<p>Attach a functional tag to the monomer using the '@' operator.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Enum</code> <p>Enum member representing the functional tag.</p> required <p>Returns:</p> Type Description <code>Monomer</code> <p>The monomer instance with the functional tag set.</p> Source code in <code>qspy\\core.py</code> <pre><code>def __matmul__(self, other: Enum):\n    \"\"\"\n    Attach a functional tag to the monomer using the '@' operator.\n\n    Parameters\n    ----------\n    other : Enum\n        Enum member representing the functional tag.\n\n    Returns\n    -------\n    Monomer\n        The monomer instance with the functional tag set.\n    \"\"\"\n    if isinstance(other, Enum):\n        ftag_str = other.value\n        ftag = FunctionalTag(*FunctionalTag.parse(ftag_str))\n        setattr(self, \"functional_tag\", ftag)\n    return self\n</code></pre>"},{"location":"reference/#qspy.core.Monomer.__pow__","title":"<code>__pow__(compartment)</code>","text":"<p>Overload the '**' operator to allow monomers to be passed with a compartment.</p> <p>This is a shortcut for creating a MonomerPattern with a compartment:   i.e., <code>monomer ** compartment</code> is equivalent to <code>monomer() ** compartment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>compartment</code> <code>Compartment</code> <p>The compartment in which the monomer pattern resides.</p> required <p>Returns:</p> Type Description <code>MonomerPattern</code> <p>A MonomerPattern from calling the monomer with the compartment.</p> Source code in <code>qspy\\core.py</code> <pre><code>def __pow__(self, compartment: Compartment):\n    \"\"\"\n    Overload the '**' operator to allow monomers to be passed with a compartment.\n\n    This is a shortcut for creating a MonomerPattern with a compartment:\n      i.e., `monomer ** compartment` is equivalent to `monomer() ** compartment`.\n\n\n    Parameters\n    ----------\n    compartment : Compartment\n        The compartment in which the monomer pattern resides.\n\n    Returns\n    -------\n    MonomerPattern\n        A MonomerPattern from calling the monomer with the compartment.\n    \"\"\"\n    if not isinstance(compartment, Compartment):\n        raise TypeError(\"Compartment must be an instance of Compartment\")\n    return self() ** compartment\n</code></pre>"},{"location":"reference/#qspy.core.Monomer.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the monomer, including the functional tag if present.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the monomer.</p> Source code in <code>qspy\\core.py</code> <pre><code>def __repr__(self):\n    \"\"\"\n    Return a string representation of the monomer, including the functional tag if present.\n\n    Returns\n    -------\n    str\n        String representation of the monomer.\n    \"\"\"\n    if self.functional_tag is None:\n        return super().__repr__()\n    else:\n        base_repr = super().__repr__()\n        return f\"{base_repr} @ {self.functional_tag.value}\"\n</code></pre>"},{"location":"reference/#qspy.core.mp_gt","title":"<code>mp_gt(self, other)</code>","text":"<p>Overload the '&gt;' operator for MonomerPattern and ComplexPattern.</p> <p>Allows creation of Observable objects with a custom name using the syntax:     pattern &gt; \"observable_name\"</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>str</code> <p>Name for the observable.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>Observable object with the specified name.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided name is not a string.</p> Source code in <code>qspy\\core.py</code> <pre><code>def mp_gt(self, other):\n    \"\"\"\n    Overload the '&gt;' operator for MonomerPattern and ComplexPattern.\n\n    Allows creation of Observable objects with a custom name using the syntax:\n        pattern &gt; \"observable_name\"\n\n    Parameters\n    ----------\n    other : str\n        Name for the observable.\n\n    Returns\n    -------\n    Observable\n        Observable object with the specified name.\n\n    Raises\n    ------\n    ValueError\n        If the provided name is not a string.\n    \"\"\"\n    if not isinstance(other, str):\n        raise ValueError(\"Observable name should be a string\")\n    else:\n        return Observable(other, self)\n</code></pre>"},{"location":"reference/#qspy.core.mp_invert","title":"<code>mp_invert(self)</code>","text":"<p>Overload the '~' operator for MonomerPattern and ComplexPattern.</p> <p>Allows creation of Observable objects using the syntax:     ~pattern</p> <p>Returns:</p> Type Description <code>Observable</code> <p>Observable object with an auto-generated name.</p> Source code in <code>qspy\\core.py</code> <pre><code>def mp_invert(self):\n    \"\"\"\n    Overload the '~' operator for MonomerPattern and ComplexPattern.\n\n    Allows creation of Observable objects using the syntax:\n        ~pattern\n\n    Returns\n    -------\n    Observable\n        Observable object with an auto-generated name.\n    \"\"\"\n\n    if isinstance(self, MonomerPattern):\n        name = _make_mono_string(self)\n\n    elif isinstance(self, ComplexPattern):\n        name = _make_complex_string(self)\n\n    # name = 'gooo'\n    return Observable(name, self)\n</code></pre>"},{"location":"reference/#qspy.core.mp_lshift","title":"<code>mp_lshift(self, value)</code>","text":"<p>Overload the '&lt;&lt;' operator for MonomerPattern and ComplexPattern.</p> <p>Allows creation of Initial objects using the syntax:     monomer_pattern &lt;&lt; value</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float or Parameter</code> <p>Initial value for the pattern.</p> required <p>Returns:</p> Type Description <code>Initial</code> <p>Initial object for the pattern.</p> Source code in <code>qspy\\core.py</code> <pre><code>def mp_lshift(self, value):\n    \"\"\"\n    Overload the '&lt;&lt;' operator for MonomerPattern and ComplexPattern.\n\n    Allows creation of Initial objects using the syntax:\n        monomer_pattern &lt;&lt; value\n\n    Parameters\n    ----------\n    value : float or Parameter\n        Initial value for the pattern.\n\n    Returns\n    -------\n    Initial\n        Initial object for the pattern.\n    \"\"\"\n    return Initial(self, value)\n</code></pre>"},{"location":"reference/#qspy.config","title":"<code>qspy.config</code>","text":""},{"location":"reference/#qspy.config--qspy-configuration-module","title":"QSPy Configuration Module","text":"<p>This module centralizes configuration constants for QSPy, including logging, unit defaults, output/reporting directories, and versioning information.</p> <p>Attributes:</p> Name Type Description <code>LOGGER_NAME</code> <code>str</code> <p>Name of the logger used throughout QSPy.</p> <code>LOG_PATH</code> <code>Path</code> <p>Path to the QSPy log file.</p> <code>DEFAULT_UNITS</code> <code>dict</code> <p>Default units for concentration, time, and volume.</p> <code>METADATA_DIR</code> <code>Path</code> <p>Directory for storing model metadata files.</p> <code>SUMMARY_DIR</code> <code>Path</code> <p>Path for the model summary markdown file.</p> <code>QSPY_VERSION</code> <code>str</code> <p>The current version of QSPy.</p>"},{"location":"reference/#qspy.config.set_log_path","title":"<code>set_log_path(path)</code>","text":"<p>Set the log file path for QSPy.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The new log file path.</p> required Source code in <code>qspy\\config.py</code> <pre><code>def set_log_path(path: str | Path):\n    \"\"\"\n    Set the log file path for QSPy.\n\n    Parameters\n    ----------\n    path : Path\n        The new log file path.\n    \"\"\"\n    global LOG_PATH\n    LOG_PATH = Path(path)\n    LOG_PATH.parent.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"reference/#qspy.config.set_logger_name","title":"<code>set_logger_name(name)</code>","text":"<p>Set the logger name for QSPy.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The new logger name.</p> required Source code in <code>qspy\\config.py</code> <pre><code>def set_logger_name(name: str):\n    \"\"\"\n    Set the logger name for QSPy.\n\n    Parameters\n    ----------\n    name : str\n        The new logger name.\n    \"\"\"\n    global LOGGER_NAME\n    LOGGER_NAME = name\n</code></pre>"},{"location":"reference/#qspy.config.set_output_dir","title":"<code>set_output_dir(path)</code>","text":"<p>Set the output directory for QSPy reports and metadata.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The new output directory path.</p> required Source code in <code>qspy\\config.py</code> <pre><code>def set_output_dir(path: str | Path):\n    \"\"\"\n    Set the output directory for QSPy reports and metadata.\n\n    Parameters\n    ----------\n    path : Path\n        The new output directory path.\n    \"\"\"\n    global OUTPUT_DIR, LOG_PATH, METADATA_DIR, SUMMARY_DIR\n    OUTPUT_DIR = Path(path)\n    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n    global LOG_PATH, METADATA_DIR, SUMMARY_DIR\n    LOG_PATH = OUTPUT_DIR / \"logs/qspy.log\"\n    METADATA_DIR = OUTPUT_DIR / \"metadata\"\n    SUMMARY_DIR = OUTPUT_DIR / \"model_summary.md\"\n</code></pre>"},{"location":"reference/#qspy.contexts.contexts","title":"<code>qspy.contexts.contexts</code>","text":""},{"location":"reference/#qspy.contexts.contexts--qspy-context-managers-for-model-construction","title":"QSPy Context Managers for Model Construction","text":"<p>This module provides context managers and utilities for structured, validated construction of quantitative systems pharmacology (QSP) models using QSPy. Each context manager encapsulates the logic for defining a specific model component (parameters, compartments, monomers, expressions, rules, initials, observables), ensuring type safety, unit checking, and extensibility.</p> <p>Classes:</p> Name Description <code>parameters   : Context manager for defining model parameters</code> <code>compartments : Context manager for defining model compartments.</code> <code>monomers     : Context manager for defining model monomers with optional functional tags.</code> <code>expressions  : Context manager for defining model expressions</code> <code>rules        : Context manager for defining model rules</code> <code>pk_macros    : Stub context manager for future pharmacokinetic macro support.</code> <p>Functions:</p> Name Description <code>initials</code> <code>observables</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with parameters():\n...     k1 = (1.0, \"1/min\")\n</code></pre> <pre><code>&gt;&gt;&gt; with monomers():\n...     A = ([\"b\"], {\"b\": [\"u\", \"p\"]})\n</code></pre> <pre><code>&gt;&gt;&gt; with rules():\n...     bind = (A(b=None) + B(), kf, kr)\n</code></pre>"},{"location":"reference/#qspy.contexts.contexts.compartments","title":"<code>compartments</code>","text":"<p>               Bases: <code>ComponentContext</code></p> <p>Context manager for defining model compartments in a QSPy model.</p> <p>Provides validation and creation logic for compartments.</p> <p>Methods:</p> Name Description <code>_validate_value</code> <p>Validate the size for a compartment.</p> <code>create_component</code> <p>Create a compartment component.</p> Source code in <code>qspy\\contexts\\contexts.py</code> <pre><code>class compartments(ComponentContext):\n    \"\"\"\n    Context manager for defining model compartments in a QSPy model.\n\n    Provides validation and creation logic for compartments.\n\n    Methods\n    -------\n    _validate_value(name, size)\n        Validate the size for a compartment.\n    create_component(name, size)\n        Create a compartment component.\n    \"\"\"\n\n    component_name = \"compartment\"\n\n    @staticmethod\n    def _validate_value(name, val):\n        \"\"\"\n        Validate the size for a compartment.\n\n        Parameters\n        ----------\n        name : str\n            Name of the compartment.\n        val : tuple | Parameter | Expression\n            Tuple of (size, dimensions) or Parameter/Expression for size.\n\n        Returns\n        -------\n        tuple\n            (size, dimensions)\n\n        Raises\n        ------\n        ValueError\n            If the size is not a Parameter or Expression.\n        \"\"\"\n        if not isinstance(val, (tuple, Parameter, Expression)):\n            raise ValueError(\n                f\"Compartment '{name}' must be a tuple: (size, dimensions) or a Parameter/Expression for size\"\n            )\n        if isinstance(val, tuple):\n            if len(val) != 2:\n                raise ValueError(\n                    f\"Compartment '{name}' tuple must be of the form (size, dimensions)\"\n                )\n            size, dimensions = val\n            if not isinstance(size, (Parameter, Expression)):\n                raise ValueError(\n                    f\"Compartment size for '{name}' must be a Parameter or Expression\"\n                )\n            if not isinstance(dimensions, int):\n                raise ValueError(\n                    f\"Compartment dimensions for '{name}' must be an integer\"\n                )\n        else:\n            size = val\n            dimensions = 3  # Default to 3D if not specified\n        return (size, dimensions)\n\n    @log_event(log_args=True, log_result=True, static_method=True)\n    @staticmethod\n    def create_component(name, size, dimensions):\n        \"\"\"\n        Create a compartment component.\n\n        Parameters\n        ----------\n        name : str\n            Name of the compartment.\n        size : Parameter or Expression\n            Size of the compartment.\n\n        Returns\n        -------\n        Compartment\n            The created compartment.\n        \"\"\"\n        compartment = Compartment(name, size=size, dimension=dimensions)\n        return compartment\n</code></pre>"},{"location":"reference/#qspy.contexts.contexts.compartments.create_component","title":"<code>create_component(name, size, dimensions)</code>  <code>staticmethod</code>","text":"<p>Create a compartment component.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the compartment.</p> required <code>size</code> <code>Parameter or Expression</code> <p>Size of the compartment.</p> required <p>Returns:</p> Type Description <code>Compartment</code> <p>The created compartment.</p> Source code in <code>qspy\\contexts\\contexts.py</code> <pre><code>@log_event(log_args=True, log_result=True, static_method=True)\n@staticmethod\ndef create_component(name, size, dimensions):\n    \"\"\"\n    Create a compartment component.\n\n    Parameters\n    ----------\n    name : str\n        Name of the compartment.\n    size : Parameter or Expression\n        Size of the compartment.\n\n    Returns\n    -------\n    Compartment\n        The created compartment.\n    \"\"\"\n    compartment = Compartment(name, size=size, dimension=dimensions)\n    return compartment\n</code></pre>"},{"location":"reference/#qspy.contexts.contexts.expressions","title":"<code>expressions</code>","text":"<p>               Bases: <code>ComponentContext</code></p> <p>Context manager for defining model expressions in a QSPy model.</p> <p>Provides validation and creation logic for expressions.</p> <p>Methods:</p> Name Description <code>_validate_value</code> <p>Validate the value for an expression.</p> <code>create_component</code> <p>Create an expression component.</p> Source code in <code>qspy\\contexts\\contexts.py</code> <pre><code>class expressions(ComponentContext):\n    \"\"\"\n    Context manager for defining model expressions in a QSPy model.\n\n    Provides validation and creation logic for expressions.\n\n    Methods\n    -------\n    _validate_value(name, val)\n        Validate the value for an expression.\n    create_component(name, expr)\n        Create an expression component.\n    \"\"\"\n\n    component_name = \"expression\"\n\n    @staticmethod\n    def _validate_value(name, val):\n        \"\"\"\n        Validate the value for an expression.\n\n        Parameters\n        ----------\n        name : str\n            Name of the expression.\n        val : sympy.Expr\n            The sympy expression.\n\n        Returns\n        -------\n        tuple\n            (val,)\n\n        Raises\n        ------\n        ValueError\n            If the value is not a sympy.Expr.\n        \"\"\"\n        # Only allow sympy expressions for expressions\n        if not isinstance(val, sympy.Expr):\n            raise ValueError(f\"Expression '{name}' must be a sympy.Expr\")\n        return (val,)\n\n    @log_event(log_args=True, log_result=True, static_method=True)\n    @staticmethod\n    def create_component(name, expr):\n        \"\"\"\n        Create an expression component.\n\n        Parameters\n        ----------\n        name : str\n            Name of the expression.\n        expr : sympy.Expr\n            The sympy expression.\n\n        Returns\n        -------\n        Expression\n            The created expression.\n        \"\"\"\n        expression = Expression(name, expr)\n        return expression\n</code></pre>"},{"location":"reference/#qspy.contexts.contexts.expressions.create_component","title":"<code>create_component(name, expr)</code>  <code>staticmethod</code>","text":"<p>Create an expression component.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the expression.</p> required <code>expr</code> <code>Expr</code> <p>The sympy expression.</p> required <p>Returns:</p> Type Description <code>Expression</code> <p>The created expression.</p> Source code in <code>qspy\\contexts\\contexts.py</code> <pre><code>@log_event(log_args=True, log_result=True, static_method=True)\n@staticmethod\ndef create_component(name, expr):\n    \"\"\"\n    Create an expression component.\n\n    Parameters\n    ----------\n    name : str\n        Name of the expression.\n    expr : sympy.Expr\n        The sympy expression.\n\n    Returns\n    -------\n    Expression\n        The created expression.\n    \"\"\"\n    expression = Expression(name, expr)\n    return expression\n</code></pre>"},{"location":"reference/#qspy.contexts.contexts.monomers","title":"<code>monomers</code>","text":"<p>               Bases: <code>ComponentContext</code></p> <p>Context manager for defining model monomers in a QSPy model.</p> <p>Provides validation and creation logic for monomers, including optional functional tags.</p> <p>Methods:</p> Name Description <code>_validate_value</code> <p>Validate the tuple for monomer definition.</p> <code>create_component</code> <p>Create a monomer component.</p> Source code in <code>qspy\\contexts\\contexts.py</code> <pre><code>class monomers(ComponentContext):\n    \"\"\"\n    Context manager for defining model monomers in a QSPy model.\n\n    Provides validation and creation logic for monomers, including optional functional tags.\n\n    Methods\n    -------\n    _validate_value(name, val)\n        Validate the tuple for monomer definition.\n    create_component(name, sites, site_states, functional_tag)\n        Create a monomer component.\n    \"\"\"\n\n    component_name = \"monomer\"\n\n    @staticmethod\n    def _validate_value(name, val):\n        \"\"\"\n        Validate the tuple for monomer definition.\n\n        Parameters\n        ----------\n        name : str\n            Name of the monomer.\n        val : tuple\n            Tuple of (sites, site_states) or (sites, site_states, functional_tag).\n\n        Returns\n        -------\n        tuple\n            (sites, site_states, functional_tag)\n\n        Raises\n        ------\n        ValueError\n            If the tuple is not valid.\n        \"\"\"\n        # Accept either (sites, site_states) or (sites, site_states, functional_tag)\n        if not isinstance(val, tuple) or (len(val) not in [2, 3]):\n            raise ValueError(\n                f\"Context-defined Monomer '{name}' must be a tuple: (sites, site_states) OR (sites, site_states, functional_tag)\"\n            )\n        if len(val) == 2:\n            sites, site_states = val\n            functional_tag = None\n        if len(val) == 3:\n            sites, site_states, functional_tag = val\n        # Validate types for each field\n        if (sites is not None) and (not isinstance(sites, list)):\n            raise ValueError(\n                f\"Monomer sites value for '{name}' must be a list of site names\"\n            )\n        if (site_states is not None) and (not isinstance(site_states, dict)):\n            raise ValueError(\n                f\"Monomer site_states for '{name}' must be a dictionary of sites and their states\"\n            )\n        if (functional_tag is not None) and (not isinstance(functional_tag, Enum)):\n            raise ValueError(\n                f\"Monomer functional tag for '{name} must be an Enum item'\"\n            )\n        return (sites, site_states, functional_tag)\n\n    @log_event(log_args=True, log_result=True, static_method=True)\n    @staticmethod\n    def create_component(name, sites, site_states, functional_tag):\n        \"\"\"\n        Create a monomer component.\n\n        Parameters\n        ----------\n        name : str\n            Name of the monomer.\n        sites : list\n            List of site names.\n        site_states : dict\n            Dictionary of site states.\n        functional_tag : Enum or None\n            Functional tag for the monomer.\n\n        Returns\n        -------\n        core.Monomer\n            The created monomer.\n        \"\"\"\n        # If no functional tag, create a plain Monomer\n        if functional_tag is None:\n            monomer = Monomer(name, sites, site_states)\n        else:\n            # If functional tag is provided, attach it\n            monomer = Monomer(name, sites, site_states) @ functional_tag\n        return monomer\n</code></pre>"},{"location":"reference/#qspy.contexts.contexts.monomers.create_component","title":"<code>create_component(name, sites, site_states, functional_tag)</code>  <code>staticmethod</code>","text":"<p>Create a monomer component.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the monomer.</p> required <code>sites</code> <code>list</code> <p>List of site names.</p> required <code>site_states</code> <code>dict</code> <p>Dictionary of site states.</p> required <code>functional_tag</code> <code>Enum or None</code> <p>Functional tag for the monomer.</p> required <p>Returns:</p> Type Description <code>Monomer</code> <p>The created monomer.</p> Source code in <code>qspy\\contexts\\contexts.py</code> <pre><code>@log_event(log_args=True, log_result=True, static_method=True)\n@staticmethod\ndef create_component(name, sites, site_states, functional_tag):\n    \"\"\"\n    Create a monomer component.\n\n    Parameters\n    ----------\n    name : str\n        Name of the monomer.\n    sites : list\n        List of site names.\n    site_states : dict\n        Dictionary of site states.\n    functional_tag : Enum or None\n        Functional tag for the monomer.\n\n    Returns\n    -------\n    core.Monomer\n        The created monomer.\n    \"\"\"\n    # If no functional tag, create a plain Monomer\n    if functional_tag is None:\n        monomer = Monomer(name, sites, site_states)\n    else:\n        # If functional tag is provided, attach it\n        monomer = Monomer(name, sites, site_states) @ functional_tag\n    return monomer\n</code></pre>"},{"location":"reference/#qspy.contexts.contexts.parameters","title":"<code>parameters</code>","text":"<p>               Bases: <code>ComponentContext</code></p> <p>Context manager for defining model parameters in a QSPy model.</p> <p>Provides validation and creation logic for parameters, supporting both numeric and symbolic (sympy.Expr) values.</p> <p>Methods:</p> Name Description <code>_validate_value</code> <p>Validate the value and unit for a parameter.</p> <code>create_component</code> <p>Create a parameter or expression component.</p> Source code in <code>qspy\\contexts\\contexts.py</code> <pre><code>class parameters(ComponentContext):\n    \"\"\"\n    Context manager for defining model parameters in a QSPy model.\n\n    Provides validation and creation logic for parameters, supporting both numeric\n    and symbolic (sympy.Expr) values.\n\n    Methods\n    -------\n    _validate_value(name, val)\n        Validate the value and unit for a parameter.\n    create_component(name, value, unit)\n        Create a parameter or expression component.\n    \"\"\"\n\n    component_name = \"parameter\"\n\n    @staticmethod\n    def _validate_value(name, val):\n        \"\"\"\n        Validate the value and unit for a parameter.\n\n        Parameters\n        ----------\n        name : str\n            Name of the parameter.\n        val : tuple\n            Tuple of (value, unit).\n\n        Returns\n        -------\n        tuple\n            (value, unit) if valid.\n\n        Raises\n        ------\n        ValueError\n            If the value or unit is invalid.\n        \"\"\"\n        # Accept sympy expressions directly as expressions\n        if isinstance(val, sympy.Expr):\n            return (val, None)\n        # Ensure tuple structure for numeric parameters\n        if not isinstance(val, tuple) or len(val) != 2:\n            raise ValueError(f\"Parameter '{name}' must be a tuple: (value, unit)\")\n        value, unit = val\n        if not isinstance(value, (int, float)):\n            raise ValueError(f\"Parameter value for '{name}' must be a number\")\n        if not isinstance(unit, str):\n            raise ValueError(f\"Unit for parameter '{name}' must be a string\")\n        return (value, unit)\n\n    @log_event(log_args=True, log_result=True, static_method=True)\n    @staticmethod\n    def create_component(name, value, unit):\n        \"\"\"\n        Create a parameter or expression component.\n\n        Parameters\n        ----------\n        name : str\n            Name of the parameter.\n        value : int, float, or sympy.Expr\n            Value of the parameter or a sympy expression.\n        unit : str or None\n            Unit for the parameter.\n\n        Returns\n        -------\n        Parameter or Expression\n            The created parameter or expression.\n        \"\"\"\n        # If value is a sympy expression, create an Expression\n        if isinstance(value, sympy.Expr):\n            expr = Expression(name, value)\n            return expr\n        # Otherwise, create a Parameter\n        param = Parameter(name, value, unit=unit)\n        return param\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"\n        Exit the parameter context and perform unit checking.\n\n        Parameters\n        ----------\n        exc_type : type\n            Exception type, if any.\n        exc_val : Exception\n            Exception value, if any.\n        exc_tb : traceback\n            Traceback, if any.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        super().__exit__(exc_type, exc_val, exc_tb)\n        # Check units for all parameters in the model\n        units_check(self.model)\n        return\n</code></pre>"},{"location":"reference/#qspy.contexts.contexts.parameters.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the parameter context and perform unit checking.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>type</code> <p>Exception type, if any.</p> required <code>exc_val</code> <code>Exception</code> <p>Exception value, if any.</p> required <code>exc_tb</code> <code>traceback</code> <p>Traceback, if any.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>qspy\\contexts\\contexts.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"\n    Exit the parameter context and perform unit checking.\n\n    Parameters\n    ----------\n    exc_type : type\n        Exception type, if any.\n    exc_val : Exception\n        Exception value, if any.\n    exc_tb : traceback\n        Traceback, if any.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    super().__exit__(exc_type, exc_val, exc_tb)\n    # Check units for all parameters in the model\n    units_check(self.model)\n    return\n</code></pre>"},{"location":"reference/#qspy.contexts.contexts.parameters.create_component","title":"<code>create_component(name, value, unit)</code>  <code>staticmethod</code>","text":"<p>Create a parameter or expression component.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the parameter.</p> required <code>value</code> <code>int, float, or sympy.Expr</code> <p>Value of the parameter or a sympy expression.</p> required <code>unit</code> <code>str or None</code> <p>Unit for the parameter.</p> required <p>Returns:</p> Type Description <code>Parameter or Expression</code> <p>The created parameter or expression.</p> Source code in <code>qspy\\contexts\\contexts.py</code> <pre><code>@log_event(log_args=True, log_result=True, static_method=True)\n@staticmethod\ndef create_component(name, value, unit):\n    \"\"\"\n    Create a parameter or expression component.\n\n    Parameters\n    ----------\n    name : str\n        Name of the parameter.\n    value : int, float, or sympy.Expr\n        Value of the parameter or a sympy expression.\n    unit : str or None\n        Unit for the parameter.\n\n    Returns\n    -------\n    Parameter or Expression\n        The created parameter or expression.\n    \"\"\"\n    # If value is a sympy expression, create an Expression\n    if isinstance(value, sympy.Expr):\n        expr = Expression(name, value)\n        return expr\n    # Otherwise, create a Parameter\n    param = Parameter(name, value, unit=unit)\n    return param\n</code></pre>"},{"location":"reference/#qspy.contexts.contexts.rules","title":"<code>rules</code>","text":"<p>               Bases: <code>ComponentContext</code></p> <p>Context manager for defining model rules in a QSPy model.</p> <p>Provides validation and creation logic for rules, supporting both reversible and irreversible forms.</p> <p>Methods:</p> Name Description <code>_validate_value</code> <p>Validate the tuple for rule definition.</p> <code>create_component</code> <p>Create a rule component.</p> Source code in <code>qspy\\contexts\\contexts.py</code> <pre><code>class rules(ComponentContext):\n    \"\"\"\n    Context manager for defining model rules in a QSPy model.\n\n    Provides validation and creation logic for rules, supporting both reversible and irreversible forms.\n\n    Methods\n    -------\n    _validate_value(name, val)\n        Validate the tuple for rule definition.\n    create_component(name, rxp, rate_forward, rate_reverse)\n        Create a rule component.\n    \"\"\"\n\n    component_name = \"rule\"\n\n    @staticmethod\n    def _validate_value(name, val):\n        \"\"\"\n        Validate the tuple for rule definition.\n\n        Parameters\n        ----------\n        name : str\n            Name of the rule.\n        val : tuple\n            Tuple of (RuleExpression, rate_forward) or (RuleExpression, rate_forward, rate_reverse).\n\n        Returns\n        -------\n        tuple\n            (rxp, rate_forward, rate_reverse)\n\n        Raises\n        ------\n        ValueError\n            If the tuple is not valid or contains invalid types.\n        \"\"\"\n        # Accept either (RuleExpression, rate_forward) or (RuleExpression, rate_forward, rate_reverse)\n        if not isinstance(val, tuple) or (len(val) &lt; 2 or len(val) &gt; 3):\n            raise ValueError(\n                f\"Rule '{name}' input must be a tuple: (RuleExpression, rate_forward) if irreversible or (RuleExpression, rate_forward, rate_reverse) if reversible\"\n            )\n        if len(val) == 2:\n            rxp, rate_forward = val\n            rate_reverse = None\n        elif len(val) == 3:\n            rxp, rate_forward, rate_reverse = val\n        # Validate types for rule components\n        if not isinstance(rxp, pysb.RuleExpression):\n            raise ValueError(f\"Rule '{name}' must contain a valid RuleExpression\")\n        if not isinstance(rate_forward, (Parameter, Expression)):\n            raise ValueError(\n                f\"rate_forward value for '{name}' must be a Parameter or Expression\"\n            )\n        if (rate_reverse is not None) and not isinstance(\n            rate_forward, (Parameter, Expression)\n        ):\n            raise ValueError(\n                f\"rate_reverse value for '{name}' must be a Parameter or Expression\"\n            )\n        return (rxp, rate_forward, rate_reverse)\n\n    @log_event(log_args=True, log_result=True, static_method=True)\n    @staticmethod\n    def create_component(name, rxp, rate_forward, rate_reverse):\n        \"\"\"\n        Create a rule component.\n\n        Parameters\n        ----------\n        name : str\n            Name of the rule.\n        rxp : pysb.RuleExpression\n            The rule expression.\n        rate_forward : Parameter or Expression\n            Forward rate parameter or expression.\n        rate_reverse : Parameter or Expression or None\n            Reverse rate parameter or expression (if reversible).\n\n        Returns\n        -------\n        Rule\n            The created rule.\n        \"\"\"\n        # Create a Rule object with the provided arguments\n        rule = Rule(name, rxp, rate_forward, rate_reverse)\n        return rule\n</code></pre>"},{"location":"reference/#qspy.contexts.contexts.rules.create_component","title":"<code>create_component(name, rxp, rate_forward, rate_reverse)</code>  <code>staticmethod</code>","text":"<p>Create a rule component.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the rule.</p> required <code>rxp</code> <code>RuleExpression</code> <p>The rule expression.</p> required <code>rate_forward</code> <code>Parameter or Expression</code> <p>Forward rate parameter or expression.</p> required <code>rate_reverse</code> <code>Parameter or Expression or None</code> <p>Reverse rate parameter or expression (if reversible).</p> required <p>Returns:</p> Type Description <code>Rule</code> <p>The created rule.</p> Source code in <code>qspy\\contexts\\contexts.py</code> <pre><code>@log_event(log_args=True, log_result=True, static_method=True)\n@staticmethod\ndef create_component(name, rxp, rate_forward, rate_reverse):\n    \"\"\"\n    Create a rule component.\n\n    Parameters\n    ----------\n    name : str\n        Name of the rule.\n    rxp : pysb.RuleExpression\n        The rule expression.\n    rate_forward : Parameter or Expression\n        Forward rate parameter or expression.\n    rate_reverse : Parameter or Expression or None\n        Reverse rate parameter or expression (if reversible).\n\n    Returns\n    -------\n    Rule\n        The created rule.\n    \"\"\"\n    # Create a Rule object with the provided arguments\n    rule = Rule(name, rxp, rate_forward, rate_reverse)\n    return rule\n</code></pre>"},{"location":"reference/#qspy.contexts.contexts.initials","title":"<code>initials()</code>","text":"<p>Context manager for defining initial conditions in a QSPy model.</p> <p>Tracks which initials are added within the context and logs them.</p> <p>Yields:</p> Type Description <code>None</code> Source code in <code>qspy\\contexts\\contexts.py</code> <pre><code>@contextmanager\ndef initials():\n    \"\"\"\n    Context manager for defining initial conditions in a QSPy model.\n\n    Tracks which initials are added within the context and logs them.\n\n    Yields\n    ------\n    None\n    \"\"\"\n    import logging\n    from pysb.core import SelfExporter\n    from qspy.config import LOGGER_NAME\n    from qspy.utils.logging import ensure_qspy_logging\n\n    ensure_qspy_logging()\n    logger = logging.getLogger(LOGGER_NAME)\n    model = SelfExporter.default_model\n\n    # Record the set of initial names before entering the context\n    initials_before = set(str(init.pattern) for init in model.initials)\n    logger.info(\"[QSPy] Entering initials context manager\")\n    try:\n        yield\n    finally:\n        # Record the set of initial names after exiting the context\n        initials_after = set(str(init.pattern) for init in model.initials)\n        added = initials_after - initials_before\n        if added:\n            # Log the names of newly added initials\n            added_initials = [\n                init for init in model.initials if str(init.pattern) in added\n            ]\n            logger.info(f\"[QSPy] Initials added in context: {added_initials}\")\n        else:\n            logger.info(\"[QSPy] No new initials added\")\n</code></pre>"},{"location":"reference/#qspy.contexts.contexts.macros","title":"<code>macros()</code>","text":"<p>Context manager for managing macros in a QSPy model.</p> <p>Yields:</p> Type Description <code>None</code> Source code in <code>qspy\\contexts\\contexts.py</code> <pre><code>@contextmanager\ndef macros():\n    \"\"\"\n    Context manager for managing macros in a QSPy model.\n\n    Yields\n    ------\n    None\n    \"\"\"\n    import logging\n    from pysb.core import SelfExporter\n    from qspy.config import LOGGER_NAME\n    from qspy.utils.logging import ensure_qspy_logging\n\n    ensure_qspy_logging()\n    logger = logging.getLogger(LOGGER_NAME)\n    model = SelfExporter.default_model\n\n    componenents_before = set(model.components.keys())\n\n    logger.info(\"[QSPy] Entering macros context manager\")\n    try:\n        yield\n    finally:\n        components_after = set(model.components.keys())\n        added = components_after - componenents_before\n        if added:\n            # Log the names of newly added components\n            added_components = [comp for comp in model.components if comp.name in added]\n            logger.info(f\"[QSPy] Components added in context: {added_components}\")\n        else:\n            logger.info(\"[QSPy] No new components added\")\n    return\n</code></pre>"},{"location":"reference/#qspy.contexts.contexts.observables","title":"<code>observables()</code>","text":"<p>Context manager for defining observables in a QSPy model.</p> <p>Yields:</p> Type Description <code>None</code> Source code in <code>qspy\\contexts\\contexts.py</code> <pre><code>@contextmanager\ndef observables():\n    \"\"\"\n    Context manager for defining observables in a QSPy model.\n\n    Yields\n    ------\n    None\n    \"\"\"\n    import logging\n    from pysb.core import SelfExporter\n    from qspy.config import LOGGER_NAME\n    from qspy.utils.logging import ensure_qspy_logging\n\n    ensure_qspy_logging()\n    logger = logging.getLogger(LOGGER_NAME)\n    model = SelfExporter.default_model\n\n    # Record the set of observable names before entering the context\n    observables_before = set(obs.name for obs in model.observables)\n    logger.info(\"[QSPy] Entering observables context manager\")\n    try:\n        yield\n    finally:\n        # Record the set of observable names after exiting the context\n        observables_after = set(init.name for init in model.observables)\n        added = observables_after - observables_before\n        if added:\n            # Log the names of newly added observables\n            added_observables = [obs for obs in model.observables if obs.name in added]\n            logger.info(f\"[QSPy] Observables added in context: {added_observables}\")\n        else:\n            logger.info(\"[QSPy] No new observables added\")\n</code></pre>"},{"location":"reference/#qspy.contexts.base","title":"<code>qspy.contexts.base</code>","text":""},{"location":"reference/#qspy.contexts.base--qspy-base-context-infrastructure","title":"QSPy Base Context Infrastructure","text":"<p>This module provides the abstract base class for QSPy context managers, which enable structured and validated construction of model components (parameters, monomers, compartments, etc.) in a PySB/QSPy model. The ComponentContext class handles introspection, variable tracking, and component injection for both manual and automatic (module-level) usage.</p> <p>Classes:</p> Name Description <code>ComponentContext : Abstract base class for all QSPy context managers.</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class MyContext(ComponentContext):\n...     def create_component(self, name, *args):\n...         # Custom creation logic\n...         pass\n...\n&gt;&gt;&gt; with MyContext():\n...     my_param = (1.0, \"1/min\")\n</code></pre>"},{"location":"reference/#qspy.contexts.base.ComponentContext","title":"<code>ComponentContext</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for QSPy context managers.</p> <p>Handles variable introspection, manual and automatic component addition, and provides a template for context-managed model construction.</p> <p>Parameters:</p> Name Type Description Default <code>manual</code> <code>bool</code> <p>If True, enables manual mode for explicit component addition (default: False).</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If True, prints verbose output during component addition (default: False).</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>component_name</code> <code>str</code> <p>Name of the component type (e.g., 'parameter', 'monomer').</p> <code>model</code> <code>Model</code> <p>The active PySB model instance.</p> <code>_manual_adds</code> <code>list</code> <p>List of manually added components (used in manual mode).</p> <code>_frame</code> <code>frame</code> <p>Reference to the caller's frame for introspection.</p> <code>_locals_before</code> <code>dict</code> <p>Snapshot of local variables before entering the context.</p> <code>_override</code> <code>bool</code> <p>If True, disables module-scope enforcement.</p> <p>Methods:</p> Name Description <code>__enter__</code> <p>Enter the context, track local variables, and enforce module scope.</p> <code>__exit__</code> <p>Exit the context, detect new variables, validate, and add components.</p> <code>__call__</code> <p>Add a component manually (manual mode only).</p> <code>_add_component</code> <p>Validate and add a component to the model.</p> <code>_validate_value</code> <p>Validate or transform the right-hand-side value (override in subclasses).</p> <code>create_component</code> <p>Abstract method to create a component (must be implemented in subclasses).</p> <code>add_component</code> <p>Add the component to the model.</p> Source code in <code>qspy\\contexts\\base.py</code> <pre><code>class ComponentContext(ABC):\n    \"\"\"\n    Abstract base class for QSPy context managers.\n\n    Handles variable introspection, manual and automatic component addition,\n    and provides a template for context-managed model construction.\n\n    Parameters\n    ----------\n    manual : bool, optional\n        If True, enables manual mode for explicit component addition (default: False).\n    verbose : bool, optional\n        If True, prints verbose output during component addition (default: False).\n\n    Attributes\n    ----------\n    component_name : str\n        Name of the component type (e.g., 'parameter', 'monomer').\n    model : pysb.Model\n        The active PySB model instance.\n    _manual_adds : list\n        List of manually added components (used in manual mode).\n    _frame : frame\n        Reference to the caller's frame for introspection.\n    _locals_before : dict\n        Snapshot of local variables before entering the context.\n    _override : bool\n        If True, disables module-scope enforcement.\n\n    Methods\n    -------\n    __enter__()\n        Enter the context, track local variables, and enforce module scope.\n    __exit__(exc_type, exc_val, exc_tb)\n        Exit the context, detect new variables, validate, and add components.\n    __call__(name, *args)\n        Add a component manually (manual mode only).\n    _add_component(name, *args)\n        Validate and add a component to the model.\n    _validate_value(name, val)\n        Validate or transform the right-hand-side value (override in subclasses).\n    create_component(name, *args)\n        Abstract method to create a component (must be implemented in subclasses).\n    add_component(component)\n        Add the component to the model.\n    \"\"\"\n\n    component_name = \"component\"  # e.g. 'parameter', 'monomer'\n\n    def __init__(self, manual: bool = False, verbose: bool = False):\n        \"\"\"\n        Initialize the context manager.\n\n        Parameters\n        ----------\n        manual : bool, optional\n            If True, enables manual mode for explicit component addition (default: False).\n        verbose : bool, optional\n            If True, prints verbose output during component addition (default: False).\n        \"\"\"\n        self.manual = manual\n        self.verbose = verbose\n        self._manual_adds = []\n        self._frame = None\n        self._locals_before = None\n        # self.components = ComponentSet()\n        self.model = SelfExporter.default_model\n        self._override = False\n\n    def __enter__(self):\n        \"\"\"\n        Enter the context manager.\n\n        Tracks local variables for automatic detection of new assignments.\n        Enforces module-level usage unless manual mode or override is enabled.\n\n        Returns\n        -------\n        self or None\n            Returns self in manual mode, otherwise None.\n\n        Raises\n        ------\n        RuntimeError\n            If no active model is found or used outside module scope.\n        \"\"\"\n        ensure_qspy_logging()\n        logger = logging.getLogger(LOGGER_NAME)\n        try:\n            logger.info(f\"[QSPy] Entering context: {self.__class__.__name__}\")\n            if self.model is None:\n                logger.error(\"No active model found. Did you instantiate a Model()?\")\n                raise RuntimeError(\n                    \"No active model found. Did you instantiate a Model()?\"\n                )\n\n            if self._override:\n                self._frame = inspect.currentframe().f_back.f_back\n            else:\n                self._frame = inspect.currentframe().f_back\n\n            # Require module-level use for introspection mode\n            if (\n                (not self.manual)\n                and (self._frame.f_globals is not self._frame.f_locals)\n            ) and (not self._override):\n                logger.error(\n                    f\"{self.__class__.__name__} must be used at module scope. \"\n                    f\"Wrap model components in a module-level script.\"\n                )\n                raise RuntimeError(\n                    f\"{self.__class__.__name__} must be used at module scope. \"\n                    f\"Wrap model components in a module-level script.\"\n                )\n\n            if not self.manual:\n                # Filter out model components and context objects before deepcopy\n\n                filtered_locals = {\n                    k: v\n                    for k, v in self._frame.f_locals.items()\n                    if not ((hasattr(v, \"__class__\") and k in SKIP_TYPES) or is_module(v))\n                }\n                # print(filtered_locals)\n                for key in filtered_locals:\n                    logger.debug(f\"Local variable: {key}\")\n                self._locals_before = copy.deepcopy(filtered_locals)\n\n            return self if self.manual else None\n        except Exception as e:\n            logger.error(f\"[QSPy][ERROR] Exception on entering context: {e}\")\n            raise\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"\n        Exit the context manager.\n\n        Detects new variables, validates, and adds components to the model.\n        In manual mode, adds components explicitly provided via __call__.\n\n        Parameters\n        ----------\n        exc_type : type\n            Exception type, if any.\n        exc_val : Exception\n            Exception value, if any.\n        exc_tb : traceback\n            Traceback, if any.\n\n        Returns\n        -------\n        None\n        \"\"\"\n\n        logger = logging.getLogger(LOGGER_NAME)\n        try:\n            logger.info(f\"[QSPy] Exiting context: {self.__class__.__name__}\")\n            if self.manual:\n                for name, *args in self._manual_adds:\n                    self._add_component(name, *args)\n            else:\n                # Filter out model components and context objects before comparison\n\n                filtered_locals = {\n                    k: v\n                    for k, v in self._frame.f_locals.items()\n                    if not ((hasattr(v, \"__class__\") and k in SKIP_TYPES) or is_module(v))\n                }\n                new_vars = set(filtered_locals.keys()) - set(self._locals_before.keys())\n\n                for var_name in new_vars:\n                    val = filtered_locals[var_name]\n                    args = self._validate_value(var_name, val)\n                    # Remove the name from the frame locals so it\n                    # can be re-added as the component.\n                    del self._frame.f_locals[var_name]\n                    self._add_component(var_name, *args)\n            # for component in self.components:\n            #     if component.name in set(self._frame.f_locals.keys()):\n            #         self._frame.f_locals[component.name] = component\n        except Exception as e:\n            logger.error(f\"[QSPy][ERROR] Exception on exiting context: {e}\")\n\n    def __call__(self, name, *args):\n        \"\"\"\n        Add a component manually (manual mode only).\n\n        Parameters\n        ----------\n        name : str\n            Name of the component.\n        *args\n            Arguments for component creation.\n\n        Raises\n        ------\n        RuntimeError\n            If called when manual mode is not enabled.\n        \"\"\"\n        if not self.manual:\n            raise RuntimeError(\n                f\"Manual mode is not enabled for this {self.__class__.__name__}\"\n            )\n        self._manual_adds.append((name, *args))\n\n    def _add_component(self, name, *args):\n        \"\"\"\n        Validate and add a component to the model.\n\n        Parameters\n        ----------\n        name : str\n            Name of the component.\n        *args\n            Arguments for component creation.\n\n        Raises\n        ------\n        ValueError\n            If the component already exists in the model.\n        \"\"\"\n        if name in self.model.component_names:\n            raise ValueError(\n                f\"{self.component_name.capitalize()} '{name}' already exists in the model.\"\n            )\n\n        component = self.create_component(name, *args)\n        self.add_component(component)\n\n        if self.verbose:\n            print(f\"[{self.component_name}] Added: {name} with args: {args}\")\n\n    def _validate_value(self, name, val):\n        \"\"\"\n        Validate or transform the right-hand-side value.\n\n        Override in subclasses if custom validation or transformation is needed.\n\n        Parameters\n        ----------\n        name : str\n            Name of the variable.\n        val : object\n            Value assigned to the variable.\n\n        Returns\n        -------\n        tuple\n            Arguments to be passed to create_component.\n\n        Raises\n        ------\n        ValueError\n            If the value is not a tuple.\n        \"\"\"\n        if not isinstance(val, tuple):\n            raise ValueError(\n                f\"{self.component_name.capitalize()} '{name}' must be defined as a tuple.\"\n            )\n        return val\n\n    @abstractmethod\n    def create_component(self, name, *args):\n        \"\"\"\n        Abstract method to create a component.\n\n        Must be implemented in subclasses.\n\n        Parameters\n        ----------\n        name : str\n            Name of the component.\n        *args\n            Arguments for component creation.\n\n        Raises\n        ------\n        NotImplementedError\n            Always, unless implemented in subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    def add_component(self, component):\n        \"\"\"\n        Add the component to the model.\n\n        Parameters\n        ----------\n        component : pysb.Component\n            The component to add.\n        \"\"\"\n        # self.components.add(component)\n        self.model.add_component(component)\n</code></pre>"},{"location":"reference/#qspy.contexts.base.ComponentContext.__call__","title":"<code>__call__(name, *args)</code>","text":"<p>Add a component manually (manual mode only).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the component.</p> required <code>*args</code> <p>Arguments for component creation.</p> <code>()</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called when manual mode is not enabled.</p> Source code in <code>qspy\\contexts\\base.py</code> <pre><code>def __call__(self, name, *args):\n    \"\"\"\n    Add a component manually (manual mode only).\n\n    Parameters\n    ----------\n    name : str\n        Name of the component.\n    *args\n        Arguments for component creation.\n\n    Raises\n    ------\n    RuntimeError\n        If called when manual mode is not enabled.\n    \"\"\"\n    if not self.manual:\n        raise RuntimeError(\n            f\"Manual mode is not enabled for this {self.__class__.__name__}\"\n        )\n    self._manual_adds.append((name, *args))\n</code></pre>"},{"location":"reference/#qspy.contexts.base.ComponentContext.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the context manager.</p> <p>Tracks local variables for automatic detection of new assignments. Enforces module-level usage unless manual mode or override is enabled.</p> <p>Returns:</p> Type Description <code>self or None</code> <p>Returns self in manual mode, otherwise None.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no active model is found or used outside module scope.</p> Source code in <code>qspy\\contexts\\base.py</code> <pre><code>def __enter__(self):\n    \"\"\"\n    Enter the context manager.\n\n    Tracks local variables for automatic detection of new assignments.\n    Enforces module-level usage unless manual mode or override is enabled.\n\n    Returns\n    -------\n    self or None\n        Returns self in manual mode, otherwise None.\n\n    Raises\n    ------\n    RuntimeError\n        If no active model is found or used outside module scope.\n    \"\"\"\n    ensure_qspy_logging()\n    logger = logging.getLogger(LOGGER_NAME)\n    try:\n        logger.info(f\"[QSPy] Entering context: {self.__class__.__name__}\")\n        if self.model is None:\n            logger.error(\"No active model found. Did you instantiate a Model()?\")\n            raise RuntimeError(\n                \"No active model found. Did you instantiate a Model()?\"\n            )\n\n        if self._override:\n            self._frame = inspect.currentframe().f_back.f_back\n        else:\n            self._frame = inspect.currentframe().f_back\n\n        # Require module-level use for introspection mode\n        if (\n            (not self.manual)\n            and (self._frame.f_globals is not self._frame.f_locals)\n        ) and (not self._override):\n            logger.error(\n                f\"{self.__class__.__name__} must be used at module scope. \"\n                f\"Wrap model components in a module-level script.\"\n            )\n            raise RuntimeError(\n                f\"{self.__class__.__name__} must be used at module scope. \"\n                f\"Wrap model components in a module-level script.\"\n            )\n\n        if not self.manual:\n            # Filter out model components and context objects before deepcopy\n\n            filtered_locals = {\n                k: v\n                for k, v in self._frame.f_locals.items()\n                if not ((hasattr(v, \"__class__\") and k in SKIP_TYPES) or is_module(v))\n            }\n            # print(filtered_locals)\n            for key in filtered_locals:\n                logger.debug(f\"Local variable: {key}\")\n            self._locals_before = copy.deepcopy(filtered_locals)\n\n        return self if self.manual else None\n    except Exception as e:\n        logger.error(f\"[QSPy][ERROR] Exception on entering context: {e}\")\n        raise\n</code></pre>"},{"location":"reference/#qspy.contexts.base.ComponentContext.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the context manager.</p> <p>Detects new variables, validates, and adds components to the model. In manual mode, adds components explicitly provided via call.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>type</code> <p>Exception type, if any.</p> required <code>exc_val</code> <code>Exception</code> <p>Exception value, if any.</p> required <code>exc_tb</code> <code>traceback</code> <p>Traceback, if any.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>qspy\\contexts\\base.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"\n    Exit the context manager.\n\n    Detects new variables, validates, and adds components to the model.\n    In manual mode, adds components explicitly provided via __call__.\n\n    Parameters\n    ----------\n    exc_type : type\n        Exception type, if any.\n    exc_val : Exception\n        Exception value, if any.\n    exc_tb : traceback\n        Traceback, if any.\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    logger = logging.getLogger(LOGGER_NAME)\n    try:\n        logger.info(f\"[QSPy] Exiting context: {self.__class__.__name__}\")\n        if self.manual:\n            for name, *args in self._manual_adds:\n                self._add_component(name, *args)\n        else:\n            # Filter out model components and context objects before comparison\n\n            filtered_locals = {\n                k: v\n                for k, v in self._frame.f_locals.items()\n                if not ((hasattr(v, \"__class__\") and k in SKIP_TYPES) or is_module(v))\n            }\n            new_vars = set(filtered_locals.keys()) - set(self._locals_before.keys())\n\n            for var_name in new_vars:\n                val = filtered_locals[var_name]\n                args = self._validate_value(var_name, val)\n                # Remove the name from the frame locals so it\n                # can be re-added as the component.\n                del self._frame.f_locals[var_name]\n                self._add_component(var_name, *args)\n        # for component in self.components:\n        #     if component.name in set(self._frame.f_locals.keys()):\n        #         self._frame.f_locals[component.name] = component\n    except Exception as e:\n        logger.error(f\"[QSPy][ERROR] Exception on exiting context: {e}\")\n</code></pre>"},{"location":"reference/#qspy.contexts.base.ComponentContext.__init__","title":"<code>__init__(manual=False, verbose=False)</code>","text":"<p>Initialize the context manager.</p> <p>Parameters:</p> Name Type Description Default <code>manual</code> <code>bool</code> <p>If True, enables manual mode for explicit component addition (default: False).</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If True, prints verbose output during component addition (default: False).</p> <code>False</code> Source code in <code>qspy\\contexts\\base.py</code> <pre><code>def __init__(self, manual: bool = False, verbose: bool = False):\n    \"\"\"\n    Initialize the context manager.\n\n    Parameters\n    ----------\n    manual : bool, optional\n        If True, enables manual mode for explicit component addition (default: False).\n    verbose : bool, optional\n        If True, prints verbose output during component addition (default: False).\n    \"\"\"\n    self.manual = manual\n    self.verbose = verbose\n    self._manual_adds = []\n    self._frame = None\n    self._locals_before = None\n    # self.components = ComponentSet()\n    self.model = SelfExporter.default_model\n    self._override = False\n</code></pre>"},{"location":"reference/#qspy.contexts.base.ComponentContext.add_component","title":"<code>add_component(component)</code>","text":"<p>Add the component to the model.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>Component</code> <p>The component to add.</p> required Source code in <code>qspy\\contexts\\base.py</code> <pre><code>def add_component(self, component):\n    \"\"\"\n    Add the component to the model.\n\n    Parameters\n    ----------\n    component : pysb.Component\n        The component to add.\n    \"\"\"\n    # self.components.add(component)\n    self.model.add_component(component)\n</code></pre>"},{"location":"reference/#qspy.contexts.base.ComponentContext.create_component","title":"<code>create_component(name, *args)</code>  <code>abstractmethod</code>","text":"<p>Abstract method to create a component.</p> <p>Must be implemented in subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the component.</p> required <code>*args</code> <p>Arguments for component creation.</p> <code>()</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always, unless implemented in subclass.</p> Source code in <code>qspy\\contexts\\base.py</code> <pre><code>@abstractmethod\ndef create_component(self, name, *args):\n    \"\"\"\n    Abstract method to create a component.\n\n    Must be implemented in subclasses.\n\n    Parameters\n    ----------\n    name : str\n        Name of the component.\n    *args\n        Arguments for component creation.\n\n    Raises\n    ------\n    NotImplementedError\n        Always, unless implemented in subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#qspy.contexts.base.is_module","title":"<code>is_module(obj)</code>","text":"<p>Check if the object is a module.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The object to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the object is a module, False otherwise.</p> Source code in <code>qspy\\contexts\\base.py</code> <pre><code>def is_module(obj):\n    \"\"\"\n    Check if the object is a module.\n\n    Parameters\n    ----------\n    obj : object\n        The object to check.\n\n    Returns\n    -------\n    bool\n        True if the object is a module, False otherwise.\n    \"\"\"\n    return isinstance(obj, ModuleType)\n</code></pre>"},{"location":"reference/#qspy.functionaltags","title":"<code>qspy.functionaltags</code>","text":""},{"location":"reference/#qspy.functionaltags--functional-tagging-utilities-for-qsp-model-components","title":"Functional Tagging Utilities for QSP Model Components","text":"<p>This module provides standardized functional tag definitions and utilities for semantic annotation of model components in quantitative systems pharmacology (QSP) models. Tags are constructed as canonical strings (e.g., \"protein::ligand\") that combine a molecular class and a functional subclass, enabling consistent labeling, introspection, and validation of model entities.</p> Classes and Enums <ul> <li>FunctionalTag : Dataclass for representing and parsing functional tags.</li> <li>PROTEIN       : Enum of common protein roles (e.g., ligand, receptor, kinase).</li> <li>DRUG          : Enum of drug roles (e.g., inhibitor, agonist, antibody).</li> <li>RNA           : Enum of RNA roles (e.g., messenger, micro, siRNA).</li> <li>DNA           : Enum of DNA roles (e.g., gene, promoter, enhancer).</li> <li>METABOLITE    : Enum of metabolite roles (e.g., substrate, product, cofactor).</li> <li>LIPID         : Enum of lipid roles (e.g., phospholipid, sterol).</li> <li>ION           : Enum of ion types (e.g., Ca2+, Na+, K+).</li> <li>NANOPARTICLE  : Enum of nanoparticle roles (e.g., drug delivery, imaging).</li> </ul> <p>Functions:</p> Name Description <code>- prefixer : Utility to construct canonical tag strings from class and function labels.</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from qspy.functionaltags import FunctionalTag, PROTEIN\n&gt;&gt;&gt; tag = FunctionalTag(\"protein\", \"ligand\")\n&gt;&gt;&gt; tag.value\n'protein::ligand'\n</code></pre> <pre><code>&gt;&gt;&gt; PROTEIN.KINASE.value\n'protein::kinase'\n</code></pre> <pre><code>&gt;&gt;&gt; FunctionalTag.parse(\"drug::inhibitor\")\n('drug', 'inhibitor')\n</code></pre>"},{"location":"reference/#qspy.functionaltags.DNA","title":"<code>DNA</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Functional tag definitions for DNA-based monomer classes.</p> <p>This enum provides standardized semantic tags for common DNA roles in quantitative systems pharmacology models. Each member is constructed using the <code>prefixer</code> utility to combine the <code>DNA_PREFIX</code> with a functional subclass label, producing values like \"dna::gene\".</p> Members <p>GENE : str     A gene region. PROMOTER : str     A promoter region. ENHANCER : str     An enhancer region.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; DNA.GENE.value\n'dna::gene'\n</code></pre> <pre><code>&gt;&gt;&gt; tag = FunctionalTag.parse(DNA.PROMOTER.value)\n('dna', 'promoter')\n</code></pre> Source code in <code>qspy\\functionaltags.py</code> <pre><code>class DNA(Enum):\n    \"\"\"\n    Functional tag definitions for DNA-based monomer classes.\n\n    This enum provides standardized semantic tags for common DNA roles\n    in quantitative systems pharmacology models. Each member is constructed\n    using the `prefixer` utility to combine the `DNA_PREFIX` with a\n    functional subclass label, producing values like \"dna::gene\".\n\n    Members\n    -------\n    GENE : str\n        A gene region.\n    PROMOTER : str\n        A promoter region.\n    ENHANCER : str\n        An enhancer region.\n\n    Examples\n    --------\n    &gt;&gt;&gt; DNA.GENE.value\n    'dna::gene'\n\n    &gt;&gt;&gt; tag = FunctionalTag.parse(DNA.PROMOTER.value)\n    ('dna', 'promoter')\n    \"\"\"\n\n    GENE = prefixer(\"gene\", DNA_PREFIX)\n    PROMOTER = prefixer(\"promoter\", DNA_PREFIX)\n    ENHANCER = prefixer(\"enhancer\", DNA_PREFIX)\n</code></pre>"},{"location":"reference/#qspy.functionaltags.DRUG","title":"<code>DRUG</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Functional tag definitions for drug-based monomer classes.</p> <p>This enum provides standardized semantic tags for common drug roles in quantitative systems pharmacology models. Each member is constructed using the <code>prefixer</code> utility to combine the <code>DRUG_PREFIX</code> with a functional subclass label, producing values like \"drug::inhibitor\".</p> <p>These tags are used in monomer definitions to support validation, introspection, and expressive annotation of pharmacological roles.</p> Members <p>SMALL_MOLECULE : str     A low molecular weight compound, typically orally bioavailable. BIOLOGIC : str     A therapeutic product derived from biological sources. ANTIBODY : str     An immunoglobulin-based therapeutic. MAB : str     A monoclonal antibody. INHIBITOR : str     A molecule that inhibits a biological process or target. AGONIST : str     A molecule that activates a receptor or pathway. ANTAGONIST : str     A molecule that blocks or dampens a biological response. INVERSE_AGONIST : str     A molecule that induces the opposite effect of an agonist. MODULATOR : str     A molecule that modulates the activity of a target. ADC : str     An antibody-drug conjugate. RLT : str     A radioligand therapy agent. PROTAC : str     A proteolysis targeting chimera. IMUNNOTHERAPY : str     An agent used in immunotherapy. CHEMOTHERAPY : str     A cytotoxic agent used in chemotherapy.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; DRUG.INHIBITOR.value\n'drug::inhibitor'\n</code></pre> <pre><code>&gt;&gt;&gt; tag = FunctionalTag.parse(DRUG.ANTIBODY.value)\n('drug', 'antibody')\n</code></pre> Source code in <code>qspy\\functionaltags.py</code> <pre><code>class DRUG(Enum):\n    \"\"\"\n    Functional tag definitions for drug-based monomer classes.\n\n    This enum provides standardized semantic tags for common drug roles\n    in quantitative systems pharmacology models. Each member is constructed\n    using the `prefixer` utility to combine the `DRUG_PREFIX` with a\n    functional subclass label, producing values like \"drug::inhibitor\".\n\n    These tags are used in monomer definitions to support validation,\n    introspection, and expressive annotation of pharmacological roles.\n\n    Members\n    -------\n    SMALL_MOLECULE : str\n        A low molecular weight compound, typically orally bioavailable.\n    BIOLOGIC : str\n        A therapeutic product derived from biological sources.\n    ANTIBODY : str\n        An immunoglobulin-based therapeutic.\n    MAB : str\n        A monoclonal antibody.\n    INHIBITOR : str\n        A molecule that inhibits a biological process or target.\n    AGONIST : str\n        A molecule that activates a receptor or pathway.\n    ANTAGONIST : str\n        A molecule that blocks or dampens a biological response.\n    INVERSE_AGONIST : str\n        A molecule that induces the opposite effect of an agonist.\n    MODULATOR : str\n        A molecule that modulates the activity of a target.\n    ADC : str\n        An antibody-drug conjugate.\n    RLT : str\n        A radioligand therapy agent.\n    PROTAC : str\n        A proteolysis targeting chimera.\n    IMUNNOTHERAPY : str\n        An agent used in immunotherapy.\n    CHEMOTHERAPY : str\n        A cytotoxic agent used in chemotherapy.\n\n    Examples\n    --------\n    &gt;&gt;&gt; DRUG.INHIBITOR.value\n    'drug::inhibitor'\n\n    &gt;&gt;&gt; tag = FunctionalTag.parse(DRUG.ANTIBODY.value)\n    ('drug', 'antibody')\n    \"\"\"\n\n    SMALL_MOLECULE = prefixer(\"small_molecule\", DRUG_PREFIX)\n    BIOLOGIC = prefixer(\"biologic\", DRUG_PREFIX)\n    ANTIBODY = prefixer(\"antibody\", DRUG_PREFIX)\n    MAB = prefixer(\"monoclonal_antibody\", DRUG_PREFIX)\n    INHIBITOR = prefixer(\"inhibitor\", DRUG_PREFIX)\n    AGONIST = prefixer(\"agonist\", DRUG_PREFIX)\n    ANTAGONIST = prefixer(\"antagonist\", DRUG_PREFIX)\n    INVERSE_AGONIST = prefixer(\"inverse_agonist\", DRUG_PREFIX)\n    MODULATOR = prefixer(\"modulator\", DRUG_PREFIX)\n    ADC = prefixer(\"antibody_drug_conjugate\", DRUG_PREFIX)\n    RLT = prefixer(\"radioligand_therapy\", DRUG_PREFIX)\n    PROTAC = prefixer(\"protac\", DRUG_PREFIX)\n    IMUNNOTHERAPY = prefixer(\"immunotherapy\", DRUG_PREFIX)\n    CHEMOTHERAPY = prefixer(\"chemotherapy\", DRUG_PREFIX)\n</code></pre>"},{"location":"reference/#qspy.functionaltags.FunctionalTag","title":"<code>FunctionalTag</code>  <code>dataclass</code>","text":"<p>Represents a functional tag for labeling monomers with semantic class/function metadata.</p> <p>A functional tag captures both a high-level molecular class (e.g., 'protein', 'rna') and a subclass or functional role (e.g., 'ligand', 'receptor'). These tags enable semantic annotation of model components to support introspection, filtering, and validation workflows.</p> <p>Parameters:</p> Name Type Description Default <code>class_</code> <code>str</code> <p>The molecular class label (e.g., 'protein').</p> required <code>function</code> <code>str</code> <p>The functional or subclass label (e.g., 'receptor').</p> required <p>Attributes:</p> Name Type Description <code>value</code> <code>str</code> <p>The canonical string representation of the tag (e.g., \"protein__receptor\"). This is derived by prefixing the function with its class using the defined separator.</p> <p>Methods:</p> Name Description <code>__eq__</code> <p>Compares functional tags by class and function. Supports comparison with other FunctionalTag instances or Enum-based tag values.</p> <code>parse</code> <p>Parses a canonical tag string into its (class, function) components.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tag = FunctionalTag(\"protein\", \"ligand\")\n&gt;&gt;&gt; tag.value\n'protein::ligand'\n</code></pre> <pre><code>&gt;&gt;&gt; FunctionalTag.parse(\"rna::micro\")\n('rna', 'micro')\n</code></pre> Source code in <code>qspy\\functionaltags.py</code> <pre><code>@dataclass(frozen=True)\nclass FunctionalTag:\n    \"\"\"\n    Represents a functional tag for labeling monomers with semantic class/function metadata.\n\n    A functional tag captures both a high-level molecular class (e.g., 'protein', 'rna') and a\n    subclass or functional role (e.g., 'ligand', 'receptor'). These tags enable semantic annotation\n    of model components to support introspection, filtering, and validation workflows.\n\n    Parameters\n    ----------\n    class_ : str\n        The molecular class label (e.g., 'protein').\n    function : str\n        The functional or subclass label (e.g., 'receptor').\n\n    Attributes\n    ----------\n    value : str\n        The canonical string representation of the tag (e.g., \"protein__receptor\").\n        This is derived by prefixing the function with its class using the defined separator.\n\n    Methods\n    -------\n    __eq__(other)\n        Compares functional tags by class and function. Supports comparison with\n        other FunctionalTag instances or Enum-based tag values.\n    parse(prefix_tag : str) -&gt; Tuple[str, str]\n        Parses a canonical tag string into its (class, function) components.\n\n    Examples\n    --------\n    &gt;&gt;&gt; tag = FunctionalTag(\"protein\", \"ligand\")\n    &gt;&gt;&gt; tag.value\n    'protein::ligand'\n\n    &gt;&gt;&gt; FunctionalTag.parse(\"rna::micro\")\n    ('rna', 'micro')\n    \"\"\"\n\n    class_: str\n    function: str\n\n    def __eq__(self, other):\n        if isinstance(other, FunctionalTag):\n            return (self.class_, self.function) == (other.class_, other.function)\n        elif isinstance(other, Enum):\n            return (self.class_, self.function) == self.parse(other.value)\n        else:\n            return False\n\n    @property\n    def value(self):\n        \"\"\"\n        str: The canonical string representation of the functional tag.\n\n        Returns the tag as a string in the format \"&lt;class&gt;::&lt;function&gt;\", e.g., \"protein::ligand\".\n\n        Examples\n        --------\n        &gt;&gt;&gt; tag = FunctionalTag(\"protein\", \"ligand\")\n        &gt;&gt;&gt; tag.value\n        'protein::ligand'\n        \"\"\"\n        return prefixer(self.function, self.class_)\n\n    @staticmethod\n    def parse(prefix_tag: str):\n        \"\"\"\n        Parse a canonical tag string into its class and function components.\n\n        Parameters\n        ----------\n        prefix_tag : str\n            The canonical tag string (e.g., \"protein::ligand\").\n\n        Returns\n        -------\n        tuple of (str, str)\n            The class and function components as a tuple.\n\n        Examples\n        --------\n        &gt;&gt;&gt; FunctionalTag.parse(\"protein::kinase\")\n        ('protein', 'kinase')\n        \"\"\"\n        class_, function = prefix_tag.split(TAG_SEP)\n        return class_, function\n</code></pre>"},{"location":"reference/#qspy.functionaltags.FunctionalTag.value","title":"<code>value</code>  <code>property</code>","text":"<p>str: The canonical string representation of the functional tag.</p> <p>Returns the tag as a string in the format \"::\", e.g., \"protein::ligand\". <p>Examples:</p> <pre><code>&gt;&gt;&gt; tag = FunctionalTag(\"protein\", \"ligand\")\n&gt;&gt;&gt; tag.value\n'protein::ligand'\n</code></pre>"},{"location":"reference/#qspy.functionaltags.FunctionalTag.parse","title":"<code>parse(prefix_tag)</code>  <code>staticmethod</code>","text":"<p>Parse a canonical tag string into its class and function components.</p> <p>Parameters:</p> Name Type Description Default <code>prefix_tag</code> <code>str</code> <p>The canonical tag string (e.g., \"protein::ligand\").</p> required <p>Returns:</p> Type Description <code>tuple of (str, str)</code> <p>The class and function components as a tuple.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; FunctionalTag.parse(\"protein::kinase\")\n('protein', 'kinase')\n</code></pre> Source code in <code>qspy\\functionaltags.py</code> <pre><code>@staticmethod\ndef parse(prefix_tag: str):\n    \"\"\"\n    Parse a canonical tag string into its class and function components.\n\n    Parameters\n    ----------\n    prefix_tag : str\n        The canonical tag string (e.g., \"protein::ligand\").\n\n    Returns\n    -------\n    tuple of (str, str)\n        The class and function components as a tuple.\n\n    Examples\n    --------\n    &gt;&gt;&gt; FunctionalTag.parse(\"protein::kinase\")\n    ('protein', 'kinase')\n    \"\"\"\n    class_, function = prefix_tag.split(TAG_SEP)\n    return class_, function\n</code></pre>"},{"location":"reference/#qspy.functionaltags.ION","title":"<code>ION</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Functional tag definitions for ion-based monomer classes.</p> <p>This enum provides standardized semantic tags for common ion types in quantitative systems pharmacology models. Each member is constructed using the <code>prefixer</code> utility to combine the <code>ION_PREFIX</code> with a functional subclass label, producing values like \"ion::ca2+\".</p> Members <p>CALCIUM : str     Calcium ion (Ca2+). POTASSIUM : str     Potassium ion (K+). SODIUM : str     Sodium ion (Na+). CHLORIDE : str     Chloride ion (Cl-). MAGNESIUM : str     Magnesium ion (Mg2+).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ION.CALCIUM.value\n'ion::ca2+'\n</code></pre> <pre><code>&gt;&gt;&gt; tag = FunctionalTag.parse(ION.SODIUM.value)\n('ion', 'na+')\n</code></pre> Source code in <code>qspy\\functionaltags.py</code> <pre><code>class ION(Enum):\n    \"\"\"\n    Functional tag definitions for ion-based monomer classes.\n\n    This enum provides standardized semantic tags for common ion types\n    in quantitative systems pharmacology models. Each member is constructed\n    using the `prefixer` utility to combine the `ION_PREFIX` with a\n    functional subclass label, producing values like \"ion::ca2+\".\n\n    Members\n    -------\n    CALCIUM : str\n        Calcium ion (Ca2+).\n    POTASSIUM : str\n        Potassium ion (K+).\n    SODIUM : str\n        Sodium ion (Na+).\n    CHLORIDE : str\n        Chloride ion (Cl-).\n    MAGNESIUM : str\n        Magnesium ion (Mg2+).\n\n    Examples\n    --------\n    &gt;&gt;&gt; ION.CALCIUM.value\n    'ion::ca2+'\n\n    &gt;&gt;&gt; tag = FunctionalTag.parse(ION.SODIUM.value)\n    ('ion', 'na+')\n    \"\"\"\n\n    CALCIUM = prefixer(\"ca2+\", ION_PREFIX)\n    POTASSIUM = prefixer(\"k+\", ION_PREFIX)\n    SODIUM = prefixer(\"na+\", ION_PREFIX)\n    CHLORIDE = prefixer(\"cl-\", ION_PREFIX)\n    MAGNESIUM = prefixer(\"mg2+\", ION_PREFIX)\n</code></pre>"},{"location":"reference/#qspy.functionaltags.LIPID","title":"<code>LIPID</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Functional tag definitions for lipid-based monomer classes.</p> <p>This enum provides standardized semantic tags for common lipid roles in quantitative systems pharmacology models. Each member is constructed using the <code>prefixer</code> utility to combine the <code>LIPID_PREFIX</code> with a functional subclass label, producing values like \"lipid::phospholipid\".</p> Members <p>PHOSPHOLIPID : str     A phospholipid molecule. GLYCOLIPID : str     A glycolipid molecule. STEROL : str     A sterol molecule. EICOSANOID : str     An eicosanoid molecule.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; LIPID.PHOSPHOLIPID.value\n'lipid::phospholipid'\n</code></pre> <pre><code>&gt;&gt;&gt; tag = FunctionalTag.parse(LIPID.STEROL.value)\n('lipid', 'sterol')\n</code></pre> Source code in <code>qspy\\functionaltags.py</code> <pre><code>class LIPID(Enum):\n    \"\"\"\n    Functional tag definitions for lipid-based monomer classes.\n\n    This enum provides standardized semantic tags for common lipid roles\n    in quantitative systems pharmacology models. Each member is constructed\n    using the `prefixer` utility to combine the `LIPID_PREFIX` with a\n    functional subclass label, producing values like \"lipid::phospholipid\".\n\n    Members\n    -------\n    PHOSPHOLIPID : str\n        A phospholipid molecule.\n    GLYCOLIPID : str\n        A glycolipid molecule.\n    STEROL : str\n        A sterol molecule.\n    EICOSANOID : str\n        An eicosanoid molecule.\n\n    Examples\n    --------\n    &gt;&gt;&gt; LIPID.PHOSPHOLIPID.value\n    'lipid::phospholipid'\n\n    &gt;&gt;&gt; tag = FunctionalTag.parse(LIPID.STEROL.value)\n    ('lipid', 'sterol')\n    \"\"\"\n\n    PHOSPHOLIPID = prefixer(\"phospholipid\", LIPID_PREFIX)\n    GLYCOLIPID = prefixer(\"glycolipid\", LIPID_PREFIX)\n    STEROL = prefixer(\"sterol\", LIPID_PREFIX)\n    EICOSANOID = prefixer(\"eicosanoid\", LIPID_PREFIX)\n</code></pre>"},{"location":"reference/#qspy.functionaltags.METABOLITE","title":"<code>METABOLITE</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Functional tag definitions for metabolite-based monomer classes.</p> <p>This enum provides standardized semantic tags for common metabolite roles in quantitative systems pharmacology models. Each member is constructed using the <code>prefixer</code> utility to combine the <code>METABOLITE_PREFIX</code> with a functional subclass label, producing values like \"metabolite::substrate\".</p> Members <p>SUBSTRATE : str     A substrate molecule in a metabolic reaction. PRODUCT : str     A product molecule in a metabolic reaction. COFACTOR : str     A cofactor required for enzyme activity.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; METABOLITE.SUBSTRATE.value\n'metabolite::substrate'\n</code></pre> <pre><code>&gt;&gt;&gt; tag = FunctionalTag.parse(METABOLITE.PRODUCT.value)\n('metabolite', 'product')\n</code></pre> Source code in <code>qspy\\functionaltags.py</code> <pre><code>class METABOLITE(Enum):\n    \"\"\"\n    Functional tag definitions for metabolite-based monomer classes.\n\n    This enum provides standardized semantic tags for common metabolite roles\n    in quantitative systems pharmacology models. Each member is constructed\n    using the `prefixer` utility to combine the `METABOLITE_PREFIX` with a\n    functional subclass label, producing values like \"metabolite::substrate\".\n\n    Members\n    -------\n    SUBSTRATE : str\n        A substrate molecule in a metabolic reaction.\n    PRODUCT : str\n        A product molecule in a metabolic reaction.\n    COFACTOR : str\n        A cofactor required for enzyme activity.\n\n    Examples\n    --------\n    &gt;&gt;&gt; METABOLITE.SUBSTRATE.value\n    'metabolite::substrate'\n\n    &gt;&gt;&gt; tag = FunctionalTag.parse(METABOLITE.PRODUCT.value)\n    ('metabolite', 'product')\n    \"\"\"\n\n    SUBSTRATE = prefixer(\"substrate\", METABOLITE_PREFIX)\n    PRODUCT = prefixer(\"product\", METABOLITE_PREFIX)\n    COFACTOR = prefixer(\"cofactor\", METABOLITE_PREFIX)\n</code></pre>"},{"location":"reference/#qspy.functionaltags.NANOPARTICLE","title":"<code>NANOPARTICLE</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Functional tag definitions for nanoparticle-based monomer classes.</p> <p>This enum provides standardized semantic tags for common nanoparticle roles in quantitative systems pharmacology models. Each member is constructed using the <code>prefixer</code> utility to combine the <code>NANOPARTICLE_PREFIX</code> with a functional subclass label, producing values like \"nanoparticle::imaging\".</p> Members <p>DRUG_DELIVERY : str     Nanoparticle for drug delivery. THERMAL : str     Photothermal nanoparticle. IMAGING : str     Nanoparticle for imaging. SENSING : str     Nanoparticle for sensing. THERANOSTIC : str     Theranostic nanoparticle.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; NANOPARTICLE.DRUG_DELIVERY.value\n'nanoparticle::drug_delivery'\n</code></pre> <pre><code>&gt;&gt;&gt; tag = FunctionalTag.parse(NANOPARTICLE.IMAGING.value)\n('nanoparticle', 'imaging')\n</code></pre> Source code in <code>qspy\\functionaltags.py</code> <pre><code>class NANOPARTICLE(Enum):\n    \"\"\"\n    Functional tag definitions for nanoparticle-based monomer classes.\n\n    This enum provides standardized semantic tags for common nanoparticle roles\n    in quantitative systems pharmacology models. Each member is constructed\n    using the `prefixer` utility to combine the `NANOPARTICLE_PREFIX` with a\n    functional subclass label, producing values like \"nanoparticle::imaging\".\n\n    Members\n    -------\n    DRUG_DELIVERY : str\n        Nanoparticle for drug delivery.\n    THERMAL : str\n        Photothermal nanoparticle.\n    IMAGING : str\n        Nanoparticle for imaging.\n    SENSING : str\n        Nanoparticle for sensing.\n    THERANOSTIC : str\n        Theranostic nanoparticle.\n\n    Examples\n    --------\n    &gt;&gt;&gt; NANOPARTICLE.DRUG_DELIVERY.value\n    'nanoparticle::drug_delivery'\n\n    &gt;&gt;&gt; tag = FunctionalTag.parse(NANOPARTICLE.IMAGING.value)\n    ('nanoparticle', 'imaging')\n    \"\"\"\n\n    DRUG_DELIVERY = prefixer(\"drug_delivery\", NANOPARTICLE_PREFIX)\n    THERMAL = prefixer(\"photothermal\", NANOPARTICLE_PREFIX)\n    IMAGING = prefixer(\"imaging\", NANOPARTICLE_PREFIX)\n    SENSING = prefixer(\"sensing\", NANOPARTICLE_PREFIX)\n    THERANOSTIC = prefixer(\"theranostic\", NANOPARTICLE_PREFIX)\n</code></pre>"},{"location":"reference/#qspy.functionaltags.PROTEIN","title":"<code>PROTEIN</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Functional tag definitions for protein-based monomer classes.</p> <p>This enum provides standardized semantic tags for common protein roles in quantitative systems pharmacology models. Each member is constructed using the <code>prefixer</code> utility to combine the <code>PROTEIN_PREFIX</code> with a functional subclass label, producing values like \"protein::ligand\".</p> <p>These tags are used in monomer definitions to support validation, introspection, and expressive annotation of biological roles.</p> Members <p>LIGAND : str     A signaling molecule that binds to a receptor. RECEPTOR : str     A membrane or intracellular protein that receives ligand signals. KINASE : str     An enzyme that phosphorylates other molecules. PHOSPHATASE : str     An enzyme that removes phosphate groups from molecules. ADAPTOR : str     A scaffold protein facilitating complex formation without enzymatic activity. TRANSCRIPTION_FACTOR : str     A nuclear protein that regulates gene transcription. ENZYME : str     A general-purpose catalytic protein. ANTIBODY : str     An immunoglobulin capable of specific antigen binding. RECEPTOR_DECOY : str     A non-signaling receptor mimic that competes with signaling receptors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PROTEIN.LIGAND.value\n'protein::ligand'\n</code></pre> <pre><code>&gt;&gt;&gt; tag = FunctionalTag.parse(PROTEIN.KINASE.value)\n('protein', 'kinase')\n</code></pre> Source code in <code>qspy\\functionaltags.py</code> <pre><code>class PROTEIN(Enum):\n    \"\"\"\n    Functional tag definitions for protein-based monomer classes.\n\n    This enum provides standardized semantic tags for common protein roles\n    in quantitative systems pharmacology models. Each member is constructed\n    using the `prefixer` utility to combine the `PROTEIN_PREFIX` with a\n    functional subclass label, producing values like \"protein::ligand\".\n\n    These tags are used in monomer definitions to support validation,\n    introspection, and expressive annotation of biological roles.\n\n    Members\n    -------\n    LIGAND : str\n        A signaling molecule that binds to a receptor.\n    RECEPTOR : str\n        A membrane or intracellular protein that receives ligand signals.\n    KINASE : str\n        An enzyme that phosphorylates other molecules.\n    PHOSPHATASE : str\n        An enzyme that removes phosphate groups from molecules.\n    ADAPTOR : str\n        A scaffold protein facilitating complex formation without enzymatic activity.\n    TRANSCRIPTION_FACTOR : str\n        A nuclear protein that regulates gene transcription.\n    ENZYME : str\n        A general-purpose catalytic protein.\n    ANTIBODY : str\n        An immunoglobulin capable of specific antigen binding.\n    RECEPTOR_DECOY : str\n        A non-signaling receptor mimic that competes with signaling receptors.\n\n    Examples\n    --------\n    &gt;&gt;&gt; PROTEIN.LIGAND.value\n    'protein::ligand'\n\n    &gt;&gt;&gt; tag = FunctionalTag.parse(PROTEIN.KINASE.value)\n    ('protein', 'kinase')\n    \"\"\"\n\n    LIGAND = prefixer(\"ligand\", PROTEIN_PREFIX)\n    RECEPTOR = prefixer(\"receptor\", PROTEIN_PREFIX)\n    KINASE = prefixer(\"kinase\", PROTEIN_PREFIX)\n    PHOSPHATASE = prefixer(\"phosphatase\", PROTEIN_PREFIX)\n    ADAPTOR = prefixer(\"adaptor\", PROTEIN_PREFIX)\n    TRANSCRIPTION_FACTOR = prefixer(\"transcription_factor\", PROTEIN_PREFIX)\n    ENZYME = prefixer(\"enzyme\", PROTEIN_PREFIX)\n    ANTIBODY = prefixer(\"antibody\", PROTEIN_PREFIX)\n    RECEPTOR_DECOY = prefixer(\"receptor_decoy\", PROTEIN_PREFIX)\n</code></pre>"},{"location":"reference/#qspy.functionaltags.RNA","title":"<code>RNA</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Functional tag definitions for RNA-based monomer classes.</p> <p>This enum provides standardized semantic tags for common RNA roles in quantitative systems pharmacology models. Each member is constructed using the <code>prefixer</code> utility to combine the <code>RNA_PREFIX</code> with a functional subclass label, producing values like \"rna::micro\".</p> Members <p>MESSENGER : str     Messenger RNA (mRNA). MICRO : str     Micro RNA (miRNA). SMALL_INTERFERING : str     Small interfering RNA (siRNA). LONG_NONCODING : str     Long non-coding RNA (lncRNA).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; RNA.MICRO.value\n'rna::micro'\n</code></pre> <pre><code>&gt;&gt;&gt; tag = FunctionalTag.parse(RNA.MESSENGER.value)\n('rna', 'messenger')\n</code></pre> Source code in <code>qspy\\functionaltags.py</code> <pre><code>class RNA(Enum):\n    \"\"\"\n    Functional tag definitions for RNA-based monomer classes.\n\n    This enum provides standardized semantic tags for common RNA roles\n    in quantitative systems pharmacology models. Each member is constructed\n    using the `prefixer` utility to combine the `RNA_PREFIX` with a\n    functional subclass label, producing values like \"rna::micro\".\n\n    Members\n    -------\n    MESSENGER : str\n        Messenger RNA (mRNA).\n    MICRO : str\n        Micro RNA (miRNA).\n    SMALL_INTERFERING : str\n        Small interfering RNA (siRNA).\n    LONG_NONCODING : str\n        Long non-coding RNA (lncRNA).\n\n    Examples\n    --------\n    &gt;&gt;&gt; RNA.MICRO.value\n    'rna::micro'\n\n    &gt;&gt;&gt; tag = FunctionalTag.parse(RNA.MESSENGER.value)\n    ('rna', 'messenger')\n    \"\"\"\n\n    MESSENGER = prefixer(\"messenger\", RNA_PREFIX)\n    MICRO = prefixer(\"micro\", RNA_PREFIX)\n    SMALL_INTERFERING = prefixer(\"small_interfering\", RNA_PREFIX)\n    LONG_NONCODING = prefixer(\"long_noncoding\", RNA_PREFIX)\n</code></pre>"},{"location":"reference/#qspy.functionaltags.prefixer","title":"<code>prefixer(function, prefix, sep=TAG_SEP)</code>","text":"<p>Constructs a canonical functional tag string by joining a class prefix and function label using the specified separator.</p> <p>This function is used to generate standardized semantic tag strings (e.g., \"protein::ligand\") for labeling model components in a consistent, machine-readable format.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>str</code> <p>The functional or subclass label (e.g., \"ligand\").</p> required <code>prefix</code> <code>str</code> <p>The class or category label to prefix the function with (e.g., \"protein\").</p> required <code>sep</code> <code>str</code> <p>Separator string used to join the prefix and function (default is <code>TAG_SEP</code>, usually \"::\").</p> <code>TAG_SEP</code> <p>Returns:</p> Type Description <code>str</code> <p>Combined class/function string (e.g., \"protein::ligand\").</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; prefixer(\"regulatory\", \"rna\")\n'rna::regulatory'\n</code></pre> <pre><code>&gt;&gt;&gt; prefixer(\"substrate\", \"metabolite\", sep=\"__\")\n'metabolite__substrate'\n</code></pre> Source code in <code>qspy\\functionaltags.py</code> <pre><code>def prefixer(function: str, prefix: str, sep: str = TAG_SEP):\n    \"\"\"\n    Constructs a canonical functional tag string by joining a class prefix\n    and function label using the specified separator.\n\n    This function is used to generate standardized semantic tag strings\n    (e.g., \"protein::ligand\") for labeling model components in a consistent,\n    machine-readable format.\n\n    Parameters\n    ----------\n    function : str\n        The functional or subclass label (e.g., \"ligand\").\n    prefix : str\n        The class or category label to prefix the function with (e.g., \"protein\").\n    sep : str, optional\n        Separator string used to join the prefix and function\n        (default is `TAG_SEP`, usually \"::\").\n\n    Returns\n    -------\n    str\n        Combined class/function string (e.g., \"protein::ligand\").\n\n    Examples\n    --------\n    &gt;&gt;&gt; prefixer(\"regulatory\", \"rna\")\n    'rna::regulatory'\n\n    &gt;&gt;&gt; prefixer(\"substrate\", \"metabolite\", sep=\"__\")\n    'metabolite__substrate'\n    \"\"\"\n\n    return \"\".join([prefix, sep, function])\n</code></pre>"},{"location":"reference/#qspy.validation.metadata","title":"<code>qspy.validation.metadata</code>","text":""},{"location":"reference/#qspy.validation.metadata--qspy-model-metadata-tracking-and-export","title":"QSPy Model Metadata Tracking and Export","text":"<p>This module provides utilities for capturing, tracking, and exporting model metadata in QSPy workflows. It includes environment capture, model hashing, and TOML export for reproducibility and provenance tracking.</p> <p>Classes:</p> Name Description <code>QSPyBench : MicroBench-based class for capturing Python and host environment info.</code> <code>ModelMetadataTracker : Tracks model metadata, environment, and provides export/load utilities.</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tracker = ModelMetadataTracker(version=\"1.0\", author=\"Alice\", export_toml=True)\n&gt;&gt;&gt; tracker.metadata[\"model_name\"]\n'MyModel'\n&gt;&gt;&gt; ModelMetadataTracker.load_metadata_toml(\"MyModel__Alice__abcd1234__2024-07-01.toml\")\n</code></pre>"},{"location":"reference/#qspy.validation.metadata.ModelMetadataTracker","title":"<code>ModelMetadataTracker</code>","text":"<p>Tracks and exports QSPy model metadata, including environment and hash.</p> <p>On initialization, captures model version, author, user, timestamp, hash, and environment metadata. Optionally exports metadata to TOML.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>Model version string (default \"0.1.0\").</p> <code>'0.1.0'</code> <code>author</code> <code>str</code> <p>Author name (default: current user).</p> <code>None</code> <code>export_toml</code> <code>bool</code> <p>If True, export metadata to TOML on creation (default: False).</p> <code>False</code> <code>capture_conda_env</code> <code>bool</code> <p>If True, capture the active conda environment name (default: False).</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>Model</code> <p>The active PySB model instance.</p> <code>version</code> <code>str</code> <p>Model version.</p> <code>author</code> <code>str</code> <p>Author name.</p> <code>current_user</code> <code>str</code> <p>Username of the current user.</p> <code>timestamp</code> <code>str</code> <p>ISO timestamp of metadata creation.</p> <code>hash</code> <code>str</code> <p>SHA256 hash of model rules and parameters.</p> <code>env_metadata</code> <code>dict</code> <p>Captured environment metadata.</p> <code>metadata</code> <code>dict</code> <p>Full metadata dictionary for export.</p> <p>Methods:</p> Name Description <code>compute_model_hash</code> <p>Compute a hash from model rules and parameters.</p> <code>capture_environment</code> <p>Capture execution environment metadata.</p> <code>export_metadata_toml</code> <p>Export metadata to a TOML file.</p> <code>load_metadata_toml</code> <p>Load metadata from a TOML file.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tracker = ModelMetadataTracker(version=\"1.0\", author=\"Alice\", export_toml=True)\n&gt;&gt;&gt; tracker.metadata[\"model_name\"]\n'MyModel'\n</code></pre> Source code in <code>qspy\\validation\\metadata.py</code> <pre><code>class ModelMetadataTracker:\n    \"\"\"\n    Tracks and exports QSPy model metadata, including environment and hash.\n\n    On initialization, captures model version, author, user, timestamp, hash, and\n    environment metadata. Optionally exports metadata to TOML.\n\n    Parameters\n    ----------\n    version : str, optional\n        Model version string (default \"0.1.0\").\n    author : str, optional\n        Author name (default: current user).\n    export_toml : bool, optional\n        If True, export metadata to TOML on creation (default: False).\n    capture_conda_env : bool, optional\n        If True, capture the active conda environment name (default: False).\n\n    Attributes\n    ----------\n    model : pysb.Model\n        The active PySB model instance.\n    version : str\n        Model version.\n    author : str\n        Author name.\n    current_user : str\n        Username of the current user.\n    timestamp : str\n        ISO timestamp of metadata creation.\n    hash : str\n        SHA256 hash of model rules and parameters.\n    env_metadata : dict\n        Captured environment metadata.\n    metadata : dict\n        Full metadata dictionary for export.\n\n    Methods\n    -------\n    compute_model_hash()\n        Compute a hash from model rules and parameters.\n    capture_environment()\n        Capture execution environment metadata.\n    export_metadata_toml(path=None, use_metadata_dir=True)\n        Export metadata to a TOML file.\n    load_metadata_toml(path)\n        Load metadata from a TOML file.\n\n    Examples\n    --------\n    &gt;&gt;&gt; tracker = ModelMetadataTracker(version=\"1.0\", author=\"Alice\", export_toml=True)\n    &gt;&gt;&gt; tracker.metadata[\"model_name\"]\n    'MyModel'\n    \"\"\"\n\n    def __init__(\n        self, version=\"0.1.0\", author=None, export_toml=False, capture_conda_env=False\n    ):\n        \"\"\"\n        Initialize the ModelMetadataTracker.\n\n        Parameters\n        ----------\n        version : str, optional\n            Model version string (default \"0.1.0\").\n        author : str, optional\n            Author name (default: current user).\n        export_toml : bool, optional\n            If True, export metadata to TOML on creation (default: False).\n        capture_conda_env : bool, optional\n            If True, capture the active conda environment name (default: False).\n\n        Raises\n        ------\n        RuntimeError\n            If no model is found in the current SelfExporter context.\n        \"\"\"\n        ensure_qspy_logging()\n        logger = logging.getLogger(LOGGER_NAME)\n        try:\n            self.model = SelfExporter.default_model\n            if not self.model:\n                logger.error(\"No model found in the current SelfExporter context\")\n                raise RuntimeError(\"No model found in the current SelfExporter context\")\n            self.version = version\n            self.author = author or \"unknown\"\n            self.current_user = getpass.getuser()\n            self.timestamp = datetime.now().isoformat()\n            self.hash = self.compute_model_hash()\n            self.env_metadata = self.capture_environment()\n\n            if capture_conda_env:\n                conda_env = os.environ.get(\"CONDA_DEFAULT_ENV\", None)\n                if conda_env:\n                    self.env_metadata[\"conda_env\"] = conda_env\n\n            self.metadata = {\n                \"version\": self.version,\n                \"author\": self.author,\n                \"current_user\": self.current_user,\n                \"created_at\": self.timestamp,\n                \"hash\": self.hash,\n                \"model_name\": self.model.name or \"unnamed_model\",\n                \"env\": self.env_metadata,\n            }\n\n            # Attach the metadata tracker to the model\n            setattr(self.model, \"qspy_metadata_tracker\", self)\n\n            if export_toml:\n                self.export_metadata_toml()\n        except Exception as e:\n            logger.error(f\"[QSPy][ERROR] Exception in ModelMetadataTracker.__init__: {e}\")\n            raise\n\n    def compute_model_hash(self):\n        \"\"\"\n        Create a hash from model definition (rules + parameters).\n\n        Returns\n        -------\n        str\n            SHA256 hash of the model's rules and parameters.\n        \"\"\"\n        try:\n            s = repr(self.model.rules) + repr(self.model.parameters)\n            return hashlib.sha256(s.encode()).hexdigest()\n        except Exception as e:\n            logger = logging.getLogger(LOGGER_NAME)\n            logger.error(f\"[QSPy][ERROR] Exception in compute_model_hash: {e}\")\n            raise\n\n    def capture_environment(self):\n        \"\"\"\n        Capture execution environment via microbench.\n\n        Returns\n        -------\n        dict\n            Dictionary of captured environment metadata.\n        \"\"\"\n        try:\n            bench = QSPyBench()\n\n            @bench\n            def noop():\n                pass\n\n            noop()\n            bench.outfile.seek(0)\n            metadata = bench.outfile.read()\n            if metadata == \"\":\n                return {\"microbench\": \"No metadata captured.\"}\n            else:\n                return json.loads(metadata)\n        except Exception as e:\n            logger = logging.getLogger(LOGGER_NAME)\n            logger.error(f\"[QSPy][ERROR] Exception in capture_environment: {e}\")\n            return {\"microbench\": f\"Error capturing metadata: {e}\"}\n\n    def export_metadata_toml(self, path=None, use_metadata_dir=True):\n        \"\"\"\n        Export metadata to a TOML file with autogenerated filename if none is provided.\n\n        Parameters\n        ----------\n        path : str or Path, optional\n            Output path for the TOML file. If None, an autogenerated filename is used.\n        use_metadata_dir : bool, optional\n            If True, use the configured METADATA_DIR for output (default: True).\n\n        Returns\n        -------\n        None\n        \"\"\"\n        ensure_qspy_logging()\n        logger = logging.getLogger(LOGGER_NAME)\n        try:\n            metadata_dir = Path(METADATA_DIR) if use_metadata_dir else Path(\".\")\n            metadata_dir.mkdir(parents=True, exist_ok=True)\n\n            if path is None:\n                safe_author = self.author.replace(\" \", \"_\")\n                safe_name = (self.model.name or \"model\").replace(\" \", \"_\")\n                short_hash = self.hash[:8]\n                safe_time = self.timestamp.replace(\":\", \"-\")\n                filename = f\"{safe_name}__{safe_author}__{short_hash}__{safe_time}.toml\"\n                path = metadata_dir / filename\n\n            with open(path, \"w\") as f:\n                toml.dump(self.metadata, f)\n            logger.info(f\"Exported model metadata to TOML: {path}\")\n        except Exception as e:\n            logger.error(f\"[QSPy][ERROR] Exception in export_metadata_toml: {e}\")\n            raise\n\n    @staticmethod\n    def load_metadata_toml(path):\n        \"\"\"\n        Load model metadata from a TOML file.\n\n        Parameters\n        ----------\n        path : str or Path\n            Path to the TOML metadata file.\n\n        Returns\n        -------\n        dict\n            Loaded metadata dictionary.\n\n        Raises\n        ------\n        Exception\n            If loading fails.\n        \"\"\"\n        ensure_qspy_logging()\n        logger = logging.getLogger(LOGGER_NAME)\n        try:\n            with open(path, \"r\") as f:\n                return toml.load(f)\n        except Exception as e:\n            logger.error(f\"[QSPy][ERROR] Exception in load_metadata_toml: {e}\")\n            raise\n</code></pre>"},{"location":"reference/#qspy.validation.metadata.ModelMetadataTracker.__init__","title":"<code>__init__(version='0.1.0', author=None, export_toml=False, capture_conda_env=False)</code>","text":"<p>Initialize the ModelMetadataTracker.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>Model version string (default \"0.1.0\").</p> <code>'0.1.0'</code> <code>author</code> <code>str</code> <p>Author name (default: current user).</p> <code>None</code> <code>export_toml</code> <code>bool</code> <p>If True, export metadata to TOML on creation (default: False).</p> <code>False</code> <code>capture_conda_env</code> <code>bool</code> <p>If True, capture the active conda environment name (default: False).</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no model is found in the current SelfExporter context.</p> Source code in <code>qspy\\validation\\metadata.py</code> <pre><code>def __init__(\n    self, version=\"0.1.0\", author=None, export_toml=False, capture_conda_env=False\n):\n    \"\"\"\n    Initialize the ModelMetadataTracker.\n\n    Parameters\n    ----------\n    version : str, optional\n        Model version string (default \"0.1.0\").\n    author : str, optional\n        Author name (default: current user).\n    export_toml : bool, optional\n        If True, export metadata to TOML on creation (default: False).\n    capture_conda_env : bool, optional\n        If True, capture the active conda environment name (default: False).\n\n    Raises\n    ------\n    RuntimeError\n        If no model is found in the current SelfExporter context.\n    \"\"\"\n    ensure_qspy_logging()\n    logger = logging.getLogger(LOGGER_NAME)\n    try:\n        self.model = SelfExporter.default_model\n        if not self.model:\n            logger.error(\"No model found in the current SelfExporter context\")\n            raise RuntimeError(\"No model found in the current SelfExporter context\")\n        self.version = version\n        self.author = author or \"unknown\"\n        self.current_user = getpass.getuser()\n        self.timestamp = datetime.now().isoformat()\n        self.hash = self.compute_model_hash()\n        self.env_metadata = self.capture_environment()\n\n        if capture_conda_env:\n            conda_env = os.environ.get(\"CONDA_DEFAULT_ENV\", None)\n            if conda_env:\n                self.env_metadata[\"conda_env\"] = conda_env\n\n        self.metadata = {\n            \"version\": self.version,\n            \"author\": self.author,\n            \"current_user\": self.current_user,\n            \"created_at\": self.timestamp,\n            \"hash\": self.hash,\n            \"model_name\": self.model.name or \"unnamed_model\",\n            \"env\": self.env_metadata,\n        }\n\n        # Attach the metadata tracker to the model\n        setattr(self.model, \"qspy_metadata_tracker\", self)\n\n        if export_toml:\n            self.export_metadata_toml()\n    except Exception as e:\n        logger.error(f\"[QSPy][ERROR] Exception in ModelMetadataTracker.__init__: {e}\")\n        raise\n</code></pre>"},{"location":"reference/#qspy.validation.metadata.ModelMetadataTracker.capture_environment","title":"<code>capture_environment()</code>","text":"<p>Capture execution environment via microbench.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of captured environment metadata.</p> Source code in <code>qspy\\validation\\metadata.py</code> <pre><code>def capture_environment(self):\n    \"\"\"\n    Capture execution environment via microbench.\n\n    Returns\n    -------\n    dict\n        Dictionary of captured environment metadata.\n    \"\"\"\n    try:\n        bench = QSPyBench()\n\n        @bench\n        def noop():\n            pass\n\n        noop()\n        bench.outfile.seek(0)\n        metadata = bench.outfile.read()\n        if metadata == \"\":\n            return {\"microbench\": \"No metadata captured.\"}\n        else:\n            return json.loads(metadata)\n    except Exception as e:\n        logger = logging.getLogger(LOGGER_NAME)\n        logger.error(f\"[QSPy][ERROR] Exception in capture_environment: {e}\")\n        return {\"microbench\": f\"Error capturing metadata: {e}\"}\n</code></pre>"},{"location":"reference/#qspy.validation.metadata.ModelMetadataTracker.compute_model_hash","title":"<code>compute_model_hash()</code>","text":"<p>Create a hash from model definition (rules + parameters).</p> <p>Returns:</p> Type Description <code>str</code> <p>SHA256 hash of the model's rules and parameters.</p> Source code in <code>qspy\\validation\\metadata.py</code> <pre><code>def compute_model_hash(self):\n    \"\"\"\n    Create a hash from model definition (rules + parameters).\n\n    Returns\n    -------\n    str\n        SHA256 hash of the model's rules and parameters.\n    \"\"\"\n    try:\n        s = repr(self.model.rules) + repr(self.model.parameters)\n        return hashlib.sha256(s.encode()).hexdigest()\n    except Exception as e:\n        logger = logging.getLogger(LOGGER_NAME)\n        logger.error(f\"[QSPy][ERROR] Exception in compute_model_hash: {e}\")\n        raise\n</code></pre>"},{"location":"reference/#qspy.validation.metadata.ModelMetadataTracker.export_metadata_toml","title":"<code>export_metadata_toml(path=None, use_metadata_dir=True)</code>","text":"<p>Export metadata to a TOML file with autogenerated filename if none is provided.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>Output path for the TOML file. If None, an autogenerated filename is used.</p> <code>None</code> <code>use_metadata_dir</code> <code>bool</code> <p>If True, use the configured METADATA_DIR for output (default: True).</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>qspy\\validation\\metadata.py</code> <pre><code>def export_metadata_toml(self, path=None, use_metadata_dir=True):\n    \"\"\"\n    Export metadata to a TOML file with autogenerated filename if none is provided.\n\n    Parameters\n    ----------\n    path : str or Path, optional\n        Output path for the TOML file. If None, an autogenerated filename is used.\n    use_metadata_dir : bool, optional\n        If True, use the configured METADATA_DIR for output (default: True).\n\n    Returns\n    -------\n    None\n    \"\"\"\n    ensure_qspy_logging()\n    logger = logging.getLogger(LOGGER_NAME)\n    try:\n        metadata_dir = Path(METADATA_DIR) if use_metadata_dir else Path(\".\")\n        metadata_dir.mkdir(parents=True, exist_ok=True)\n\n        if path is None:\n            safe_author = self.author.replace(\" \", \"_\")\n            safe_name = (self.model.name or \"model\").replace(\" \", \"_\")\n            short_hash = self.hash[:8]\n            safe_time = self.timestamp.replace(\":\", \"-\")\n            filename = f\"{safe_name}__{safe_author}__{short_hash}__{safe_time}.toml\"\n            path = metadata_dir / filename\n\n        with open(path, \"w\") as f:\n            toml.dump(self.metadata, f)\n        logger.info(f\"Exported model metadata to TOML: {path}\")\n    except Exception as e:\n        logger.error(f\"[QSPy][ERROR] Exception in export_metadata_toml: {e}\")\n        raise\n</code></pre>"},{"location":"reference/#qspy.validation.metadata.ModelMetadataTracker.load_metadata_toml","title":"<code>load_metadata_toml(path)</code>  <code>staticmethod</code>","text":"<p>Load model metadata from a TOML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>Path to the TOML metadata file.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Loaded metadata dictionary.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If loading fails.</p> Source code in <code>qspy\\validation\\metadata.py</code> <pre><code>@staticmethod\ndef load_metadata_toml(path):\n    \"\"\"\n    Load model metadata from a TOML file.\n\n    Parameters\n    ----------\n    path : str or Path\n        Path to the TOML metadata file.\n\n    Returns\n    -------\n    dict\n        Loaded metadata dictionary.\n\n    Raises\n    ------\n    Exception\n        If loading fails.\n    \"\"\"\n    ensure_qspy_logging()\n    logger = logging.getLogger(LOGGER_NAME)\n    try:\n        with open(path, \"r\") as f:\n            return toml.load(f)\n    except Exception as e:\n        logger.error(f\"[QSPy][ERROR] Exception in load_metadata_toml: {e}\")\n        raise\n</code></pre>"},{"location":"reference/#qspy.validation.metadata.QSPyBench","title":"<code>QSPyBench</code>","text":"<p>               Bases: <code>MicroBench</code>, <code>MBPythonVersion</code>, <code>MBHostInfo</code></p> <p>MicroBench-based class for capturing Python and host environment information.</p> <p>Captures versions of key scientific libraries and host metadata for reproducibility.</p> <p>Attributes:</p> Name Type Description <code>capture_versions</code> <code>tuple</code> <p>Tuple of modules to capture version info for (qspy, numpy, scipy, sympy, pysb, pysb.pkpd, pysb.units, mergram).</p> Source code in <code>qspy\\validation\\metadata.py</code> <pre><code>class QSPyBench(MicroBench, MBPythonVersion, MBHostInfo):\n    \"\"\"\n    MicroBench-based class for capturing Python and host environment information.\n\n    Captures versions of key scientific libraries and host metadata for reproducibility.\n\n    Attributes\n    ----------\n    capture_versions : tuple\n        Tuple of modules to capture version info for (qspy, numpy, scipy, sympy, pysb, pysb.pkpd, pysb.units, mergram).\n    \"\"\"\n    capture_versions = (qspy, numpy, scipy, sympy, pysb, pysb.pkpd, pysb.units, mergram)\n</code></pre>"},{"location":"reference/#qspy.validation.modelchecker","title":"<code>qspy.validation.modelchecker</code>","text":""},{"location":"reference/#qspy.validation.modelchecker--qspy-modelchecker-utilities","title":"QSPy ModelChecker Utilities","text":"<p>This module provides the ModelChecker class for validating PySB/QSPy models. It checks for unused or zero-valued parameters, unused monomers, missing initial conditions, dangling bonds, unit consistency, and other common modeling issues. Warnings are logged and also issued as Python warnings for user visibility.</p> <p>Classes:</p> Name Description <code>ModelChecker : Performs a suite of checks on a PySB/QSPy model for common issues.</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; checker = ModelChecker(model)\n&gt;&gt;&gt; checker.check()\n</code></pre>"},{"location":"reference/#qspy.validation.modelchecker.ModelChecker","title":"<code>ModelChecker</code>","text":"<p>Performs a suite of checks on a PySB/QSPy model for common modeling issues.</p> <p>Checks include: - Unused monomers - Unused parameters - Zero-valued parameters - Missing initial conditions - Dangling/reused bonds - Unit consistency - (Optional) unbound sites, overdefined rules, unreferenced expressions</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to check. If None, uses the current SelfExporter.default_model.</p> <code>None</code> <code>logger_name</code> <code>str</code> <p>Name of the logger to use (default: LOGGER_NAME).</p> <code>LOGGER_NAME</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>Model</code> <p>The model being checked.</p> <code>logger</code> <code>Logger</code> <p>Logger for outputting warnings and info.</p> Source code in <code>qspy\\validation\\modelchecker.py</code> <pre><code>class ModelChecker:\n    \"\"\"\n    Performs a suite of checks on a PySB/QSPy model for common modeling issues.\n\n    Checks include:\n    - Unused monomers\n    - Unused parameters\n    - Zero-valued parameters\n    - Missing initial conditions\n    - Dangling/reused bonds\n    - Unit consistency\n    - (Optional) unbound sites, overdefined rules, unreferenced expressions\n\n    Parameters\n    ----------\n    model : pysb.Model, optional\n        The model to check. If None, uses the current SelfExporter.default_model.\n    logger_name : str, optional\n        Name of the logger to use (default: LOGGER_NAME).\n\n    Attributes\n    ----------\n    model : pysb.Model\n        The model being checked.\n    logger : logging.Logger\n        Logger for outputting warnings and info.\n    \"\"\"\n\n    def __init__(self, model=None, logger_name=LOGGER_NAME):\n        \"\"\"\n        Initialize the ModelChecker.\n\n        Parameters\n        ----------\n        model : pysb.Model, optional\n            The model to check. If None, uses the current SelfExporter.default_model.\n        logger_name : str, optional\n            Name of the logger to use.\n        \"\"\"\n        self.model = model\n        if model is None:\n            self.model = SelfExporter.default_model\n        ensure_qspy_logging()\n        self.logger = logging.getLogger(logger_name)\n        self.check()\n\n    @log_event()\n    def check(self):\n        \"\"\"\n        Run all model checks.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.logger.info(\"\ud83d\udd0d Running ModelChecker...\")\n        self.check_unused_monomers()\n        self.check_unused_parameters()\n        self.check_zero_valued_parameters()\n        self.check_missing_initial_conditions()\n        # self.check_unconnected_species()\n        # self.check_unbound_sites()\n        # self.check_overdefined_rules()\n        # self.check_unreferenced_expressions()\n        # units_check(self.model)\n        self.check_dangling_reused_bonds()\n        self.check_units()\n        self.check_equations_generation()\n        self.logger.info(\"\u2705 ModelChecker checks completed.\")\n\n    def check_unused_monomers(self):\n        \"\"\"\n        Check for monomers that are not used in any rules.\n\n        Logs and warns about unused monomers.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        used = set()\n        for rule in self.model.rules:\n            used.update(\n                m.name\n                for m in monomers_from_pattern(rule.rule_expression.reactant_pattern)\n            )\n            # monomers_from_pattern doesn't handle None, so we need to\n            # check here or it will cause a problem with the set.union method.\n            if rule.is_reversible:\n                used.update(\n                    m.name\n                    for m in monomers_from_pattern(rule.rule_expression.product_pattern)\n                )\n\n        unused = [m.name for m in self.model.monomers if m.name not in used]\n        if len(unused) &gt; 0:\n            msg = f\"Unused Monomers (not included in any Rules): {[m for m in unused]}\"\n            self.logger.warning(f\"\u26a0\ufe0f {msg}\")\n            warnings.warn(msg, category=UserWarning)\n            print(f\"\u26a0\ufe0f {msg}\")  # Print to console for visibility\n\n    def check_unused_parameters(self):\n        \"\"\"\n        Check for parameters that are not used in rules, initials, or expressions.\n\n        Logs and warns about unused parameters.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        used = set()\n        for rule in self.model.rules:\n            if isinstance(rule.rate_forward, Parameter):\n                used.add(rule.rate_forward.name)\n            if rule.is_reversible:\n                if isinstance(rule.rate_reverse, Parameter):\n                    used.add(rule.rate_reverse.name)\n        for ic in self.model.initials:\n            if isinstance(ic.value, Parameter):\n                used.add(ic.value.name)\n        for expr in self.model.expressions:\n            used.update(p.name for p in expr.expr.atoms(Parameter))\n        for compartment in self.model.compartments:\n            if isinstance(compartment.size, Parameter):\n                used.add(compartment.size.name)\n\n        unused = [p.name for p in self.model.parameters if p.name not in used]\n        if unused:\n            msg = f\"Unused Parameters: {[p for p in unused]}\"\n            self.logger.warning(f\"\u26a0\ufe0f {msg}\")\n            warnings.warn(msg, category=UserWarning)\n            print(f\"\u26a0\ufe0f {msg}\")  # Print to console for visibility\n\n    def check_zero_valued_parameters(self):\n        \"\"\"\n        Check for parameters with a value of zero.\n\n        Logs and warns about zero-valued parameters.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        zeros = [p for p in self.model.parameters if np.isclose(p.value, 0.0)]\n        if zeros:\n            msg = f\"Zero-valued Parameters: {[p.name for p in zeros]}\"\n            self.logger.warning(f\"\u26a0\ufe0f {msg}\")\n            warnings.warn(msg, category=UserWarning)\n            print(f\"\u26a0\ufe0f {msg}\")  # Print to console for visibility\n\n    def check_missing_initial_conditions(self):\n        \"\"\"\n        Check for monomers missing initial conditions.\n\n        Logs and warns about monomers that do not have initial conditions defined.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        defined = list()\n        for initial in self.model.initials:\n            for m in monomers_from_pattern(initial.pattern):\n                defined.append(m.name)\n        defined = set(defined)\n        all_monomers = set(m.name for m in self.model.monomers)\n        missing = all_monomers - defined\n        if missing:\n            msg = f\"Monomers missing initial conditions: {list(missing)}\"\n            self.logger.warning(f\"\u26a0\ufe0f {msg}\")\n            warnings.warn(msg, category=UserWarning)\n            print(f\"\u26a0\ufe0f {msg}\")  # Print to console for visibility\n\n    def check_dangling_reused_bonds(self):\n        \"\"\"\n        Check for dangling or reused bonds in all rules.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        for rule in self.model.rules:\n            try:\n                check_dangling_bonds(rule.rule_expression.reactant_pattern)\n            except Exception as e:\n                msg = f\"Error checking reactant pattern in rule '{rule.name}': {e}\"\n                self.logger.error(msg)\n                warnings.warn(msg, category=UserWarning)\n                print(msg)  # Print to console for visibility\n            if rule.is_reversible:\n                try:\n                    check_dangling_bonds(rule.rule_expression.product_pattern)\n                except Exception as e:\n                    msg = f\"Error checking product pattern in rule '{rule.name}': {e}\"\n                    self.logger.error(msg)\n                    warnings.warn(msg, category=UserWarning)\n                    print(msg)  # Print to console for visibility\n\n    def check_equations_generation(self):\n        \"\"\"\n        Run the `generate_equations` function on the model and capture and report any errors.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        try:\n            generate_equations(self.model)\n            self.logger.info(\"Model equations generated successfully.\")\n        except Exception as e:\n            msg = f\"Error generating model equations: {e}\"\n            self.logger.error(msg)\n            warnings.warn(msg, category=UserWarning)\n            print(msg)  # Print to console for visibility\n\n    @log_event()\n    def check_units(self):\n        \"\"\"\n        Check for unit consistency in the model.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        units_check(self.model)\n\n    def check_unbound_sites(self):\n        \"\"\"\n        Check for sites that never participate in bonds.\n\n        Logs and warns about unbound sites.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        bound_sites = set()\n        for r in self.model.rules:\n            for cp in r.rule_expression().all_complex_patterns():\n                for m in cp.monomer_patterns:\n                    for site, state in m.site_conditions.items():\n                        if isinstance(state, tuple):  # bond tuple\n                            bound_sites.add((m.monomer.name, site))\n\n        unbound = []\n        for m in self.model.monomers:\n            for site in m.sites:\n                if (m.name, site) not in bound_sites:\n                    unbound.append(f\"{m.name}.{site}\")\n\n        if unbound:\n            msg = f\"Unbound Sites (never participate in bonds): {unbound}\"\n            self.logger.warning(f\"\u26a0\ufe0f {msg}\")\n            warnings.warn(msg, category=UserWarning)\n\n    def check_overdefined_rules(self):\n        \"\"\"\n        Check for rules that define the same reaction more than once.\n\n        Logs and warns about overdefined rules.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        seen = {}\n        for r in self.model.rules:\n            rxn = str(r.rule_expression())\n            if rxn in seen:\n                msg = f\"Overdefined reaction: '{rxn}' in rules `{seen[rxn]}` and `{r.name}`\"\n                self.logger.warning(f\"\u26a0\ufe0f {msg}\")\n                warnings.warn(msg, category=UserWarning)\n            else:\n                seen[rxn] = r.name\n\n    def check_unreferenced_expressions(self):\n        \"\"\"\n        Check for expressions that are not referenced by any rule or observable.\n\n        Logs and warns about unreferenced expressions.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        used = set()\n        for rule in self.model.rules:\n            if rule.rate_forward:\n                used.update(str(p) for p in rule.rate_forward.parameters)\n            if rule.rate_reverse:\n                used.update(str(p) for p in rule.rate_reverse.parameters)\n        for o in self.model.observables:\n            used.update(str(p) for p in o.function.atoms(Parameter))\n\n        exprs = [e.name for e in self.model.expressions if e.name not in used]\n        if exprs:\n            msg = f\"Unreferenced Expressions: {exprs}\"\n            self.logger.warning(f\"\u26a0\ufe0f {msg}\")\n            warnings.warn(msg, category=UserWarning)\n</code></pre>"},{"location":"reference/#qspy.validation.modelchecker.ModelChecker.__init__","title":"<code>__init__(model=None, logger_name=LOGGER_NAME)</code>","text":"<p>Initialize the ModelChecker.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to check. If None, uses the current SelfExporter.default_model.</p> <code>None</code> <code>logger_name</code> <code>str</code> <p>Name of the logger to use.</p> <code>LOGGER_NAME</code> Source code in <code>qspy\\validation\\modelchecker.py</code> <pre><code>def __init__(self, model=None, logger_name=LOGGER_NAME):\n    \"\"\"\n    Initialize the ModelChecker.\n\n    Parameters\n    ----------\n    model : pysb.Model, optional\n        The model to check. If None, uses the current SelfExporter.default_model.\n    logger_name : str, optional\n        Name of the logger to use.\n    \"\"\"\n    self.model = model\n    if model is None:\n        self.model = SelfExporter.default_model\n    ensure_qspy_logging()\n    self.logger = logging.getLogger(logger_name)\n    self.check()\n</code></pre>"},{"location":"reference/#qspy.validation.modelchecker.ModelChecker.check","title":"<code>check()</code>","text":"<p>Run all model checks.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>qspy\\validation\\modelchecker.py</code> <pre><code>@log_event()\ndef check(self):\n    \"\"\"\n    Run all model checks.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.logger.info(\"\ud83d\udd0d Running ModelChecker...\")\n    self.check_unused_monomers()\n    self.check_unused_parameters()\n    self.check_zero_valued_parameters()\n    self.check_missing_initial_conditions()\n    # self.check_unconnected_species()\n    # self.check_unbound_sites()\n    # self.check_overdefined_rules()\n    # self.check_unreferenced_expressions()\n    # units_check(self.model)\n    self.check_dangling_reused_bonds()\n    self.check_units()\n    self.check_equations_generation()\n    self.logger.info(\"\u2705 ModelChecker checks completed.\")\n</code></pre>"},{"location":"reference/#qspy.validation.modelchecker.ModelChecker.check_dangling_reused_bonds","title":"<code>check_dangling_reused_bonds()</code>","text":"<p>Check for dangling or reused bonds in all rules.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>qspy\\validation\\modelchecker.py</code> <pre><code>def check_dangling_reused_bonds(self):\n    \"\"\"\n    Check for dangling or reused bonds in all rules.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    for rule in self.model.rules:\n        try:\n            check_dangling_bonds(rule.rule_expression.reactant_pattern)\n        except Exception as e:\n            msg = f\"Error checking reactant pattern in rule '{rule.name}': {e}\"\n            self.logger.error(msg)\n            warnings.warn(msg, category=UserWarning)\n            print(msg)  # Print to console for visibility\n        if rule.is_reversible:\n            try:\n                check_dangling_bonds(rule.rule_expression.product_pattern)\n            except Exception as e:\n                msg = f\"Error checking product pattern in rule '{rule.name}': {e}\"\n                self.logger.error(msg)\n                warnings.warn(msg, category=UserWarning)\n                print(msg)  # Print to console for visibility\n</code></pre>"},{"location":"reference/#qspy.validation.modelchecker.ModelChecker.check_equations_generation","title":"<code>check_equations_generation()</code>","text":"<p>Run the <code>generate_equations</code> function on the model and capture and report any errors.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>qspy\\validation\\modelchecker.py</code> <pre><code>def check_equations_generation(self):\n    \"\"\"\n    Run the `generate_equations` function on the model and capture and report any errors.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    try:\n        generate_equations(self.model)\n        self.logger.info(\"Model equations generated successfully.\")\n    except Exception as e:\n        msg = f\"Error generating model equations: {e}\"\n        self.logger.error(msg)\n        warnings.warn(msg, category=UserWarning)\n        print(msg)  # Print to console for visibility\n</code></pre>"},{"location":"reference/#qspy.validation.modelchecker.ModelChecker.check_missing_initial_conditions","title":"<code>check_missing_initial_conditions()</code>","text":"<p>Check for monomers missing initial conditions.</p> <p>Logs and warns about monomers that do not have initial conditions defined.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>qspy\\validation\\modelchecker.py</code> <pre><code>def check_missing_initial_conditions(self):\n    \"\"\"\n    Check for monomers missing initial conditions.\n\n    Logs and warns about monomers that do not have initial conditions defined.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    defined = list()\n    for initial in self.model.initials:\n        for m in monomers_from_pattern(initial.pattern):\n            defined.append(m.name)\n    defined = set(defined)\n    all_monomers = set(m.name for m in self.model.monomers)\n    missing = all_monomers - defined\n    if missing:\n        msg = f\"Monomers missing initial conditions: {list(missing)}\"\n        self.logger.warning(f\"\u26a0\ufe0f {msg}\")\n        warnings.warn(msg, category=UserWarning)\n        print(f\"\u26a0\ufe0f {msg}\")  # Print to console for visibility\n</code></pre>"},{"location":"reference/#qspy.validation.modelchecker.ModelChecker.check_overdefined_rules","title":"<code>check_overdefined_rules()</code>","text":"<p>Check for rules that define the same reaction more than once.</p> <p>Logs and warns about overdefined rules.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>qspy\\validation\\modelchecker.py</code> <pre><code>def check_overdefined_rules(self):\n    \"\"\"\n    Check for rules that define the same reaction more than once.\n\n    Logs and warns about overdefined rules.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    seen = {}\n    for r in self.model.rules:\n        rxn = str(r.rule_expression())\n        if rxn in seen:\n            msg = f\"Overdefined reaction: '{rxn}' in rules `{seen[rxn]}` and `{r.name}`\"\n            self.logger.warning(f\"\u26a0\ufe0f {msg}\")\n            warnings.warn(msg, category=UserWarning)\n        else:\n            seen[rxn] = r.name\n</code></pre>"},{"location":"reference/#qspy.validation.modelchecker.ModelChecker.check_unbound_sites","title":"<code>check_unbound_sites()</code>","text":"<p>Check for sites that never participate in bonds.</p> <p>Logs and warns about unbound sites.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>qspy\\validation\\modelchecker.py</code> <pre><code>def check_unbound_sites(self):\n    \"\"\"\n    Check for sites that never participate in bonds.\n\n    Logs and warns about unbound sites.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    bound_sites = set()\n    for r in self.model.rules:\n        for cp in r.rule_expression().all_complex_patterns():\n            for m in cp.monomer_patterns:\n                for site, state in m.site_conditions.items():\n                    if isinstance(state, tuple):  # bond tuple\n                        bound_sites.add((m.monomer.name, site))\n\n    unbound = []\n    for m in self.model.monomers:\n        for site in m.sites:\n            if (m.name, site) not in bound_sites:\n                unbound.append(f\"{m.name}.{site}\")\n\n    if unbound:\n        msg = f\"Unbound Sites (never participate in bonds): {unbound}\"\n        self.logger.warning(f\"\u26a0\ufe0f {msg}\")\n        warnings.warn(msg, category=UserWarning)\n</code></pre>"},{"location":"reference/#qspy.validation.modelchecker.ModelChecker.check_units","title":"<code>check_units()</code>","text":"<p>Check for unit consistency in the model.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>qspy\\validation\\modelchecker.py</code> <pre><code>@log_event()\ndef check_units(self):\n    \"\"\"\n    Check for unit consistency in the model.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    units_check(self.model)\n</code></pre>"},{"location":"reference/#qspy.validation.modelchecker.ModelChecker.check_unreferenced_expressions","title":"<code>check_unreferenced_expressions()</code>","text":"<p>Check for expressions that are not referenced by any rule or observable.</p> <p>Logs and warns about unreferenced expressions.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>qspy\\validation\\modelchecker.py</code> <pre><code>def check_unreferenced_expressions(self):\n    \"\"\"\n    Check for expressions that are not referenced by any rule or observable.\n\n    Logs and warns about unreferenced expressions.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    used = set()\n    for rule in self.model.rules:\n        if rule.rate_forward:\n            used.update(str(p) for p in rule.rate_forward.parameters)\n        if rule.rate_reverse:\n            used.update(str(p) for p in rule.rate_reverse.parameters)\n    for o in self.model.observables:\n        used.update(str(p) for p in o.function.atoms(Parameter))\n\n    exprs = [e.name for e in self.model.expressions if e.name not in used]\n    if exprs:\n        msg = f\"Unreferenced Expressions: {exprs}\"\n        self.logger.warning(f\"\u26a0\ufe0f {msg}\")\n        warnings.warn(msg, category=UserWarning)\n</code></pre>"},{"location":"reference/#qspy.validation.modelchecker.ModelChecker.check_unused_monomers","title":"<code>check_unused_monomers()</code>","text":"<p>Check for monomers that are not used in any rules.</p> <p>Logs and warns about unused monomers.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>qspy\\validation\\modelchecker.py</code> <pre><code>def check_unused_monomers(self):\n    \"\"\"\n    Check for monomers that are not used in any rules.\n\n    Logs and warns about unused monomers.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    used = set()\n    for rule in self.model.rules:\n        used.update(\n            m.name\n            for m in monomers_from_pattern(rule.rule_expression.reactant_pattern)\n        )\n        # monomers_from_pattern doesn't handle None, so we need to\n        # check here or it will cause a problem with the set.union method.\n        if rule.is_reversible:\n            used.update(\n                m.name\n                for m in monomers_from_pattern(rule.rule_expression.product_pattern)\n            )\n\n    unused = [m.name for m in self.model.monomers if m.name not in used]\n    if len(unused) &gt; 0:\n        msg = f\"Unused Monomers (not included in any Rules): {[m for m in unused]}\"\n        self.logger.warning(f\"\u26a0\ufe0f {msg}\")\n        warnings.warn(msg, category=UserWarning)\n        print(f\"\u26a0\ufe0f {msg}\")  # Print to console for visibility\n</code></pre>"},{"location":"reference/#qspy.validation.modelchecker.ModelChecker.check_unused_parameters","title":"<code>check_unused_parameters()</code>","text":"<p>Check for parameters that are not used in rules, initials, or expressions.</p> <p>Logs and warns about unused parameters.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>qspy\\validation\\modelchecker.py</code> <pre><code>def check_unused_parameters(self):\n    \"\"\"\n    Check for parameters that are not used in rules, initials, or expressions.\n\n    Logs and warns about unused parameters.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    used = set()\n    for rule in self.model.rules:\n        if isinstance(rule.rate_forward, Parameter):\n            used.add(rule.rate_forward.name)\n        if rule.is_reversible:\n            if isinstance(rule.rate_reverse, Parameter):\n                used.add(rule.rate_reverse.name)\n    for ic in self.model.initials:\n        if isinstance(ic.value, Parameter):\n            used.add(ic.value.name)\n    for expr in self.model.expressions:\n        used.update(p.name for p in expr.expr.atoms(Parameter))\n    for compartment in self.model.compartments:\n        if isinstance(compartment.size, Parameter):\n            used.add(compartment.size.name)\n\n    unused = [p.name for p in self.model.parameters if p.name not in used]\n    if unused:\n        msg = f\"Unused Parameters: {[p for p in unused]}\"\n        self.logger.warning(f\"\u26a0\ufe0f {msg}\")\n        warnings.warn(msg, category=UserWarning)\n        print(f\"\u26a0\ufe0f {msg}\")  # Print to console for visibility\n</code></pre>"},{"location":"reference/#qspy.validation.modelchecker.ModelChecker.check_zero_valued_parameters","title":"<code>check_zero_valued_parameters()</code>","text":"<p>Check for parameters with a value of zero.</p> <p>Logs and warns about zero-valued parameters.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>qspy\\validation\\modelchecker.py</code> <pre><code>def check_zero_valued_parameters(self):\n    \"\"\"\n    Check for parameters with a value of zero.\n\n    Logs and warns about zero-valued parameters.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    zeros = [p for p in self.model.parameters if np.isclose(p.value, 0.0)]\n    if zeros:\n        msg = f\"Zero-valued Parameters: {[p.name for p in zeros]}\"\n        self.logger.warning(f\"\u26a0\ufe0f {msg}\")\n        warnings.warn(msg, category=UserWarning)\n        print(f\"\u26a0\ufe0f {msg}\")  # Print to console for visibility\n</code></pre>"},{"location":"reference/#qspy.utils.diagrams","title":"<code>qspy.utils.diagrams</code>","text":""},{"location":"reference/#qspy.utils.diagrams--qspy-model-diagram-generation-utilities","title":"QSPy Model Diagram Generation Utilities","text":"<p>This module provides utilities for generating flowchart-style diagrams of QSPy/PySB models. It leverages mergram and pyvipr to visualize model structure, including compartments, species, and reactions, and can export diagrams as Mermaid, Markdown, or HTML blocks.</p> <p>Classes:</p> Name Description <code>ModelMermaidDiagrammer : Generates and exports flowchart diagrams for a given model.</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from qspy.diagrams import ModelDiagram\n&gt;&gt;&gt; diagram = ModelDiagram(model)\n&gt;&gt;&gt; print(diagram.markdown_block)\n&gt;&gt;&gt; diagram.write_mermaid_file(\"model_flowchart.mmd\")\n</code></pre>"},{"location":"reference/#qspy.utils.diagrams.ModelMermaidDiagrammer","title":"<code>ModelMermaidDiagrammer</code>","text":"<p>Generates a Mermaid flowchart diagram of a QSPy/PySB model.</p> <p>This class builds a flowchart representation of the model, including compartments, species, and reactions, and provides export options for Mermaid, Markdown, and HTML.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to visualize. If None, uses the current SelfExporter.default_model.</p> <code>None</code> <code>output_dir</code> <code>str or Path</code> <p>Directory to write diagram files (default: METADATA_DIR).</p> <code>METADATA_DIR</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>Model</code> <p>The model being visualized.</p> <code>flowchart</code> <code>Flowchart</code> <p>The generated flowchart object.</p> <code>static_viz</code> <code>PysbStaticViz</code> <p>Static visualization helper for the model.</p> <code>has_compartments</code> <code>bool</code> <p>Whether the model contains compartments.</p> <code>output_dir</code> <code>Path</code> <p>Directory for output files.</p> <p>Methods:</p> Name Description <code>write_mermaid_file</code> <p>Write the flowchart to a Mermaid file.</p> <code>markdown_block</code> <p>Return the flowchart as a Markdown block.</p> <code>html_block</code> <p>Return the flowchart as an HTML block.</p> Source code in <code>qspy\\utils\\diagrams.py</code> <pre><code>class ModelMermaidDiagrammer:\n    \"\"\"\n    Generates a Mermaid flowchart diagram of a QSPy/PySB model.\n\n    This class builds a flowchart representation of the model, including compartments,\n    species, and reactions, and provides export options for Mermaid, Markdown, and HTML.\n\n    Parameters\n    ----------\n    model : pysb.Model, optional\n        The model to visualize. If None, uses the current SelfExporter.default_model.\n    output_dir : str or Path, optional\n        Directory to write diagram files (default: METADATA_DIR).\n\n    Attributes\n    ----------\n    model : pysb.Model\n        The model being visualized.\n    flowchart : Flowchart\n        The generated flowchart object.\n    static_viz : PysbStaticViz\n        Static visualization helper for the model.\n    has_compartments : bool\n        Whether the model contains compartments.\n    output_dir : Path\n        Directory for output files.\n\n    Methods\n    -------\n    write_mermaid_file(file_path)\n        Write the flowchart to a Mermaid file.\n    markdown_block\n        Return the flowchart as a Markdown block.\n    html_block\n        Return the flowchart as an HTML block.\n    \"\"\"\n\n    def __init__(self, model=None, output_dir=METADATA_DIR):\n        \"\"\"\n        Initialize the ModelMermaidDiagrammer.\n\n        Parameters\n        ----------\n        model : pysb.Model, optional\n            The model to visualize. If None, uses the current SelfExporter.default_model.\n        output_dir : str or Path, optional\n            Directory to write diagram files (default: METADATA_DIR).\n        \"\"\"\n        self.model = model\n        if model is None:\n            self.model = SelfExporter.default_model\n        self.flowchart = Flowchart(self.model.name)\n        self.static_viz = PysbStaticViz(self.model)\n        self.has_compartments = len(self.model.compartments) &gt; 0\n        self._build_flowchart()\n        self.output_dir = Path(output_dir)\n        self.output_dir.mkdir(parents=True, exist_ok=True)\n        chart_file = self.output_dir / f\"{self.model.name}_flowchart.mmd\"\n        self.write_mermaid_file(chart_file.as_posix())\n        setattr(self.model, \"mermaid_diagram\", self)\n        return\n\n    @staticmethod\n    def _sanitize_label(label):\n        \"\"\"\n        Sanitize a label by removing compartment information.\n\n        Parameters\n        ----------\n        label : str\n            The label to sanitize.\n\n        Returns\n        -------\n        str\n            The sanitized label without compartment information.\n        \"\"\"\n        #print(label)\n        if \"** \" in label:\n            if \"-\" in label:\n                # Remove compartment from labels with bound monomers\n                # e.g., \"molec_a() ** CENTRAL % molec_b() ** TUMOR\"\n                # becomes \"molec_a() % molec_b()\"\n                parts = label.split(\"-\")\n                return parts[0].split(\"** \")[0] + \":\" + parts[1].split(\"** \")[0]\n            else:\n                # Remove compartment info\n                # e.g., \"molec_a() ** CENTRAL\" -&gt; \"molec_a()\"\n                return label.split(\"** \")[0]\n        return label\n\n    def _build_flowchart(self):\n        \"\"\"\n        Build the flowchart representation of the model.\n\n        Parses the model's compartments, species, and reactions, and adds them as nodes,\n        subgraphs, and links to the flowchart.\n        \"\"\"\n        if self.has_compartments:\n            nx_graph = self.static_viz.compartments_data_graph()\n        else:\n            nx_graph = self.static_viz.species_graph()\n        # Add nodes and edges for unidirection `&gt;&gt; None` reactions.\n        # This is to handle cases where a reaction has no products.\n        for reaction in self.model.reactions_bidirectional:\n            reactants = set(reaction[\"reactants\"])\n            products = set(reaction[\"products\"])\n            rule = self.model.rules[reaction[\"rule\"][0]]\n            k_f = rule.rate_forward.name\n            if len(products) &lt; 1:\n                for s in reactants:\n                    s_id = f\"s{s}\"\n                    node_comp = nx_graph.nodes[s_id][\"parent\"]\n                    nx_graph.add_node(\n                        \"none\",\n                        NodeType=\"none\",\n                        parent=node_comp,\n                        label='\"fa:fa-circle-xmark\"',\n                        background_color=\"#fff\",\n                    )\n                    nx_graph.add_edge(s_id, \"none\", k_f=k_f, k_r=\" \")\n\n        # Parse the networkx graph nodes into flowchart nodes.\n        # Create subgraphs for compartments if they exist.\n        # Otherwise, create nodes for species.\n        flow_nodes = dict()\n        for node_id, node_attr in nx_graph.nodes.data():\n            if node_attr[\"NodeType\"] == \"compartment\":\n                if node_id not in self.flowchart.subgraphs:\n                    self.flowchart += Subgraph(node_id)\n            elif node_attr[\"NodeType\"] == \"species\":\n                flow_node = Node(\n                    node_id,\n                    label=self._sanitize_label(node_attr.get(\"label\", node_id)),\n                    fill=node_attr.get(\"background_color\", \"#fff\"),\n                )\n                compartment = node_attr[\"parent\"]\n                if compartment not in self.flowchart.subgraphs:\n                    self.flowchart += Subgraph(compartment)\n                self.flowchart.subgraphs[compartment] += flow_node\n                flow_nodes[node_id] = flow_node\n            elif node_attr[\"NodeType\"] == \"none\":\n                flow_node = Node(\n                    node_id,\n                    label=self._sanitize_label(node_attr.get(\"label\", node_id)),\n                    fill=node_attr.get(\"background_color\", \"#fff\"),\n                    shape=\"fr-circ\",\n                )\n                self.flowchart += flow_node\n                flow_nodes[node_id] = flow_node\n        # Go through the reactions and get the names of rate constants\n        # and add them to the networkx edge attributes.\n        for reaction in self.model.reactions_bidirectional:\n            reactants = set(reaction[\"reactants\"])\n            products = set(reaction[\"products\"])\n            rule = self.model.rules[reaction[\"rule\"][0]]\n            k_f = rule.rate_forward.name\n            if rule.rate_reverse is None:\n                k_r = \" \"\n            else:\n                k_r = rule.rate_reverse.name\n\n            for s in reactants:\n                s_id = f\"s{s}\"\n                for p in products:\n                    p_id = f\"s{p}\"\n                    if nx_graph.has_edge(s_id, p_id):\n                        nx_graph[s_id][p_id][\"k_f\"] = k_f\n                        nx_graph[s_id][p_id][\"k_r\"] = k_r\n\n        for source, target, edge_attr in nx_graph.edges.data():\n            if source in flow_nodes and target in flow_nodes:\n                self.flowchart += Link(\n                    flow_nodes[source],\n                    flow_nodes[target],\n                    text=edge_attr.get(\"k_f\", \" \"),\n                )\n                if edge_attr.get(\"source_arrow_shape\") == \"triangle\":\n                    # Reaction is reversible\n                    self.flowchart += Link(\n                        flow_nodes[target],\n                        flow_nodes[source],\n                        text=edge_attr.get(\"k_r\", \" \"),\n                    )\n        # Add colors to subgraphs for compartments\n        comp_colors = sns.color_palette(\n            \"Set2\", n_colors=len(self.flowchart.subgraphs)\n        ).as_hex()\n        for subgraph in self.flowchart.subgraphs.values():\n            s_id = subgraph.title\n            style = Style(\n                s_id,\n                rx=\"10px\",\n                fill=comp_colors.pop(0),\n                color=\"#000\",\n            )\n            self.flowchart += style\n\n        return\n\n    @property\n    def markdown_block(self):\n        \"\"\"\n        Return the flowchart as a Markdown block.\n\n        Returns\n        -------\n        str\n            Markdown representation of the flowchart.\n        \"\"\"\n        return self.flowchart.to_markdown()\n\n    @property\n    def html_block(self):\n        \"\"\"\n        Return the flowchart as an HTML block.\n\n        Returns\n        -------\n        str\n            HTML representation of the flowchart.\n        \"\"\"\n        return self.flowchart.to_html()\n\n    def write_mermaid_file(self, file_path):\n        \"\"\"\n        Write the flowchart to a Mermaid file.\n\n        Parameters\n        ----------\n        file_path : str or Path\n            Path to the output Mermaid (.mmd) file.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.flowchart.write(file_path)\n        return\n</code></pre>"},{"location":"reference/#qspy.utils.diagrams.ModelMermaidDiagrammer.html_block","title":"<code>html_block</code>  <code>property</code>","text":"<p>Return the flowchart as an HTML block.</p> <p>Returns:</p> Type Description <code>str</code> <p>HTML representation of the flowchart.</p>"},{"location":"reference/#qspy.utils.diagrams.ModelMermaidDiagrammer.markdown_block","title":"<code>markdown_block</code>  <code>property</code>","text":"<p>Return the flowchart as a Markdown block.</p> <p>Returns:</p> Type Description <code>str</code> <p>Markdown representation of the flowchart.</p>"},{"location":"reference/#qspy.utils.diagrams.ModelMermaidDiagrammer.__init__","title":"<code>__init__(model=None, output_dir=METADATA_DIR)</code>","text":"<p>Initialize the ModelMermaidDiagrammer.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to visualize. If None, uses the current SelfExporter.default_model.</p> <code>None</code> <code>output_dir</code> <code>str or Path</code> <p>Directory to write diagram files (default: METADATA_DIR).</p> <code>METADATA_DIR</code> Source code in <code>qspy\\utils\\diagrams.py</code> <pre><code>def __init__(self, model=None, output_dir=METADATA_DIR):\n    \"\"\"\n    Initialize the ModelMermaidDiagrammer.\n\n    Parameters\n    ----------\n    model : pysb.Model, optional\n        The model to visualize. If None, uses the current SelfExporter.default_model.\n    output_dir : str or Path, optional\n        Directory to write diagram files (default: METADATA_DIR).\n    \"\"\"\n    self.model = model\n    if model is None:\n        self.model = SelfExporter.default_model\n    self.flowchart = Flowchart(self.model.name)\n    self.static_viz = PysbStaticViz(self.model)\n    self.has_compartments = len(self.model.compartments) &gt; 0\n    self._build_flowchart()\n    self.output_dir = Path(output_dir)\n    self.output_dir.mkdir(parents=True, exist_ok=True)\n    chart_file = self.output_dir / f\"{self.model.name}_flowchart.mmd\"\n    self.write_mermaid_file(chart_file.as_posix())\n    setattr(self.model, \"mermaid_diagram\", self)\n    return\n</code></pre>"},{"location":"reference/#qspy.utils.diagrams.ModelMermaidDiagrammer.write_mermaid_file","title":"<code>write_mermaid_file(file_path)</code>","text":"<p>Write the flowchart to a Mermaid file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str or Path</code> <p>Path to the output Mermaid (.mmd) file.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>qspy\\utils\\diagrams.py</code> <pre><code>def write_mermaid_file(self, file_path):\n    \"\"\"\n    Write the flowchart to a Mermaid file.\n\n    Parameters\n    ----------\n    file_path : str or Path\n        Path to the output Mermaid (.mmd) file.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.flowchart.write(file_path)\n    return\n</code></pre>"},{"location":"reference/#qspy.utils.logging","title":"<code>qspy.utils.logging</code>","text":""},{"location":"reference/#qspy.utils.logging--qspy-logging-utilities","title":"QSPy Logging Utilities","text":"<p>This module provides logging utilities for QSPy, including logger setup, event decorators, metadata redaction, and context entry/exit logging. It ensures consistent, structured, and optionally redacted logging for QSPy workflows.</p> <p>Functions:</p> Name Description <code>setup_qspy_logger : Set up the QSPy logger with rotating file handler.</code> <code>ensure_qspy_logging : Ensure the QSPy logger is initialized.</code> <code>log_event : Decorator for logging function entry, exit, arguments, and results.</code> <code>redact_sensitive : Recursively redact sensitive fields in a dictionary.</code> <code>log_model_metadata : Log model metadata in a structured, optionally redacted format.</code> <code>log_context_entry_exit : Decorator for logging context manager entry/exit.</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @log_event(log_args=True, log_result=True)\n... def foo(x): return x + 1\n&gt;&gt;&gt; foo(2)\n</code></pre>"},{"location":"reference/#qspy.utils.logging.ensure_qspy_logging","title":"<code>ensure_qspy_logging()</code>","text":"<p>Ensure the QSPy logger is initialized.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>qspy\\utils\\logging.py</code> <pre><code>def ensure_qspy_logging():\n    \"\"\"\n    Ensure the QSPy logger is initialized.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    global _LOGGER_INITIALIZED\n    if not _LOGGER_INITIALIZED:\n        setup_qspy_logger()\n        _LOGGER_INITIALIZED = True\n</code></pre>"},{"location":"reference/#qspy.utils.logging.log_context_entry_exit","title":"<code>log_context_entry_exit(logger_name=LOGGER_NAME, log_duration=True, track_attr=None)</code>","text":"<p>Decorator for logging context manager entry and exit, with optional duration and tracking.</p> <p>Parameters:</p> Name Type Description Default <code>logger_name</code> <code>str</code> <p>Name of the logger to use (default: LOGGER_NAME).</p> <code>LOGGER_NAME</code> <code>log_duration</code> <code>bool</code> <p>If True, log the duration of the context (default: True).</p> <code>True</code> <code>track_attr</code> <code>str or None</code> <p>If provided, track additions to this model attribute (e.g., 'rules').</p> <code>None</code> <p>Returns:</p> Type Description <code>function</code> <p>Decorated context manager method.</p> Source code in <code>qspy\\utils\\logging.py</code> <pre><code>def log_context_entry_exit(logger_name=LOGGER_NAME, log_duration=True, track_attr=None):\n    \"\"\"\n    Decorator for logging context manager entry and exit, with optional duration and tracking.\n\n    Parameters\n    ----------\n    logger_name : str, optional\n        Name of the logger to use (default: LOGGER_NAME).\n    log_duration : bool, optional\n        If True, log the duration of the context (default: True).\n    track_attr : str or None, optional\n        If provided, track additions to this model attribute (e.g., 'rules').\n\n    Returns\n    -------\n    function\n        Decorated context manager method.\n    \"\"\"\n\n    def decorator(method):\n        @functools.wraps(method)\n        def wrapper(self, *args, **kwargs):\n            logger = logging.getLogger(logger_name)\n            context_name = getattr(self, \"name\", self.__class__.__name__)\n            is_enter = method.__name__ == \"__enter__\"\n            is_exit = method.__name__ == \"__exit__\"\n\n            if is_enter:\n                self._qspy_context_start = time.time()\n                self._qspy_pre_ids = set()\n                if track_attr:\n                    tracked = getattr(self.model, track_attr, [])\n                    self._qspy_pre_ids = set(id(x) for x in tracked)\n                logger.info(f\"&gt;&gt;&gt; Entering context: `{context_name}`\")\n\n            result = method(self, *args, **kwargs)\n\n            if is_exit:\n                duration = \"\"\n                if log_duration and hasattr(self, \"_qspy_context_start\"):\n                    elapsed = time.time() - self._qspy_context_start\n                    duration = f\" (duration: {elapsed:.3f}s)\"\n                logger.info(f\"&lt;&lt;&lt; Exiting context: `{context_name}`{duration}\")\n\n                if track_attr:\n                    tracked = getattr(self.model, track_attr, [])\n                    added = [x for x in tracked if id(x) not in self._qspy_pre_ids]\n                    logger.info(f\"    \u21b3 Added {len(added)} new `{track_attr}`:\")\n                    for obj in added:\n                        logger.info(f\"       - {getattr(obj, 'name', repr(obj))}\")\n\n            return result\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/#qspy.utils.logging.log_event","title":"<code>log_event(logger_name=LOGGER_NAME, log_args=False, log_result=False, static_method=False)</code>","text":"<p>Decorator for logging function entry, exit, arguments, and results.</p> <p>Parameters:</p> Name Type Description Default <code>logger_name</code> <code>str</code> <p>Name of the logger to use (default: LOGGER_NAME).</p> <code>LOGGER_NAME</code> <code>log_args</code> <code>bool</code> <p>If True, log function arguments (default: False).</p> <code>False</code> <code>log_result</code> <code>bool</code> <p>If True, log function result (default: False).</p> <code>False</code> <code>static_method</code> <code>bool</code> <p>If True, skip the first argument (for static methods).</p> <code>False</code> <p>Returns:</p> Type Description <code>function</code> <p>Decorated function with logging.</p> Source code in <code>qspy\\utils\\logging.py</code> <pre><code>def log_event(\n    logger_name=LOGGER_NAME, log_args=False, log_result=False, static_method=False\n):\n    \"\"\"\n    Decorator for logging function entry, exit, arguments, and results.\n\n    Parameters\n    ----------\n    logger_name : str, optional\n        Name of the logger to use (default: LOGGER_NAME).\n    log_args : bool, optional\n        If True, log function arguments (default: False).\n    log_result : bool, optional\n        If True, log function result (default: False).\n    static_method : bool, optional\n        If True, skip the first argument (for static methods).\n\n    Returns\n    -------\n    function\n        Decorated function with logging.\n    \"\"\"\n    ensure_qspy_logging()\n    logger = logging.getLogger(logger_name)\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            if static_method:\n                args = args[1:]\n            fname = func.__qualname__\n            logger.info(f\"&gt;&gt;&gt; Entering `{fname}`\")\n            if log_args:\n                logger.info(f\"    Args: {args}, Kwargs: {kwargs}\")\n            start = time.time()\n            result = func(*args, **kwargs)\n            duration = time.time() - start\n            logger.info(f\"&lt;&lt;&lt; Exiting `{fname}` ({duration:.3f}s)\")\n            if log_result:\n                logger.info(f\"    Result: {result}\")\n            return result\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/#qspy.utils.logging.log_model_metadata","title":"<code>log_model_metadata(metadata, logger_name=LOGGER_NAME, level=logging.INFO, redact=True)</code>","text":"<p>Log QSPy model metadata in structured format, with optional redaction.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>The metadata dictionary to log.</p> required <code>logger_name</code> <code>str</code> <p>Name of the logger.</p> <code>LOGGER_NAME</code> <code>level</code> <code>int</code> <p>Logging level.</p> <code>INFO</code> <code>redact</code> <code>bool</code> <p>If True, redact sensitive fields (default: True).</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>qspy\\utils\\logging.py</code> <pre><code>def log_model_metadata(\n    metadata, logger_name=LOGGER_NAME, level=logging.INFO, redact=True\n):\n    \"\"\"\n    Log QSPy model metadata in structured format, with optional redaction.\n\n    Parameters\n    ----------\n    metadata : dict\n        The metadata dictionary to log.\n    logger_name : str, optional\n        Name of the logger.\n    level : int, optional\n        Logging level.\n    redact : bool, optional\n        If True, redact sensitive fields (default: True).\n\n    Returns\n    -------\n    None\n    \"\"\"\n    logger = logging.getLogger(logger_name)\n    if not metadata:\n        logger.warning(\"No metadata provided to log.\")\n        return\n\n    header = \"QSPy metadata snapshot\"\n    if redact:\n        metadata = redact_sensitive(metadata)\n        header += \" (sensitive fields redacted)\"\n    logger.log(level, header + \":\")\n\n    for line in pprint.pformat(metadata, indent=2).splitlines():\n        logger.log(level, f\"    {line}\")\n</code></pre>"},{"location":"reference/#qspy.utils.logging.redact_sensitive","title":"<code>redact_sensitive(data)</code>","text":"<p>Recursively redact sensitive fields in a dictionary or list.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict or list or object</code> <p>The data structure to redact.</p> required <p>Returns:</p> Type Description <code>object</code> <p>The redacted data structure.</p> Source code in <code>qspy\\utils\\logging.py</code> <pre><code>def redact_sensitive(data):\n    \"\"\"\n    Recursively redact sensitive fields in a dictionary or list.\n\n    Parameters\n    ----------\n    data : dict or list or object\n        The data structure to redact.\n\n    Returns\n    -------\n    object\n        The redacted data structure.\n    \"\"\"\n    if isinstance(data, dict):\n        return {\n            k: \"[REDACTED]\" if k in REDACT_KEYS else redact_sensitive(v)\n            for k, v in data.items()\n        }\n    elif isinstance(data, list):\n        return [redact_sensitive(i) for i in data]\n    return data\n</code></pre>"},{"location":"reference/#qspy.utils.logging.setup_qspy_logger","title":"<code>setup_qspy_logger(log_path=LOG_PATH, max_bytes=1000000, backup_count=5, level=logging.INFO)</code>","text":"<p>Set up the QSPy logger with a rotating file handler.</p> <p>Parameters:</p> Name Type Description Default <code>log_path</code> <code>str or Path</code> <p>Path to the log file (default: LOG_PATH).</p> <code>LOG_PATH</code> <code>max_bytes</code> <code>int</code> <p>Maximum size of a log file before rotation (default: 1,000,000).</p> <code>1000000</code> <code>backup_count</code> <code>int</code> <p>Number of backup log files to keep (default: 5).</p> <code>5</code> <code>level</code> <code>int</code> <p>Logging level (default: logging.INFO).</p> <code>INFO</code> <p>Returns:</p> Type Description <code>Logger</code> <p>The configured QSPy logger.</p> Source code in <code>qspy\\utils\\logging.py</code> <pre><code>def setup_qspy_logger(\n    log_path=LOG_PATH, max_bytes=1_000_000, backup_count=5, level=logging.INFO\n):\n    \"\"\"\n    Set up the QSPy logger with a rotating file handler.\n\n    Parameters\n    ----------\n    log_path : str or Path, optional\n        Path to the log file (default: LOG_PATH).\n    max_bytes : int, optional\n        Maximum size of a log file before rotation (default: 1,000,000).\n    backup_count : int, optional\n        Number of backup log files to keep (default: 5).\n    level : int, optional\n        Logging level (default: logging.INFO).\n\n    Returns\n    -------\n    logging.Logger\n        The configured QSPy logger.\n    \"\"\"\n    log_file = Path(log_path)\n    log_file.parent.mkdir(parents=True, exist_ok=True)\n\n    handler = RotatingFileHandler(\n        filename=log_file,\n        maxBytes=max_bytes,\n        backupCount=backup_count,\n        encoding=\"utf-8\",\n    )\n\n    formatter = logging.Formatter(\n        fmt=\"%(asctime)s [%(levelname)s] %(message)s\", datefmt=\"%Y-%m-%d %H:%M:%S\"\n    )\n    handler.setFormatter(formatter)\n\n    logger = logging.getLogger(LOGGER_NAME)\n    logger.setLevel(level)\n\n    if not logger.hasHandlers():  # Prevent duplicate handlers on reload\n        logger.addHandler(handler)\n\n    logger.info(\"QSPy logging initialized.\")\n    return logger\n</code></pre>"},{"location":"reference/#experimental-features","title":"Experimental Features","text":""},{"location":"reference/#qspy.experimental.infix_macros","title":"<code>qspy.experimental.infix_macros</code>","text":"<p>QSPy experimental infix macros for expressive model syntax.</p> <p>Provides infix-style macro objects for binding, elimination, and equilibrium interactions: - binds: infix macro for reversible binding reactions - eliminated: infix macro for elimination reactions - equilibrates: infix macro for reversible state transitions</p> <p>These macros enable expressive model code such as:     species binds target &amp; (k_f, k_r)     species eliminated compartment &amp; k_deg     state1 equilibrates state2 &amp; (k_f, k_r)</p>"},{"location":"reference/#qspy.experimental.infix_macros.InfixMacro","title":"<code>InfixMacro</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for infix-style macros in QSPy.</p> <p>This class provides a structure for creating infix-style macros that can be used in a way that more closely resembles specifying a biological action. Adapted from <code>Infix</code> class example at: https://discuss.python.org/t/infix-function-in-python/41820/2</p> Source code in <code>qspy\\experimental\\infix_macros.py</code> <pre><code>class InfixMacro(ABC):\n    \"\"\"\n    Abstract base class for infix-style macros in QSPy.\n\n    This class provides a structure for creating infix-style macros that can be used\n    in a way that more closely resembles specifying a biological action.\n    Adapted from `Infix` class example at: https://discuss.python.org/t/infix-function-in-python/41820/2\n    \"\"\"\n\n    def __init__(self, lhs=None, rhs=None):\n        \"\"\"\n        Initialize the infix macro with optional left and right sides.\n\n        Parameters\n        ----------\n        lhs : any, optional\n            The left-hand side of the infix operation.\n        rhs : any, optional\n            The right-hand side of the infix operation.\n        \"\"\"\n        self.lhs = lhs\n        self.rhs = rhs\n\n    @abstractmethod\n    def execute_macro(self, lhs, rhs, at):\n        \"\"\"\n        Abstract method to execute the macro logic.\n\n        Parameters\n        ----------\n        lhs : any\n            The left-hand side operand.\n        rhs : any\n            The right-hand side operand.\n        at : any\n            Additional argument for the macro.\n\n        Returns\n        -------\n        any\n            The result of the macro operation.\n        \"\"\"\n        pass\n\n    def __rmul__(self, lhs):\n        \"\"\"\n        Capture the left-hand side operand for the infix macro.\n\n        Parameters\n        ----------\n        lhs : any\n            The left-hand side operand.\n\n        Returns\n        -------\n        InfixMacro\n            The same instance with lhs set.\n        \"\"\"\n        self.lhs = lhs\n        return self\n\n    def __mul__(self, rhs):\n        \"\"\"\n        Capture the right-hand side operand for the infix macro.\n\n        Parameters\n        ----------\n        rhs : any\n            The right-hand side operand.\n\n        Returns\n        -------\n        InfixMacro\n            The same instance with rhs set.\n        \"\"\"\n        self.rhs = rhs\n        return self\n\n    def __and__(self, at):\n        \"\"\"\n        Execute the macro logic using the &amp; operator.\n\n        Parameters\n        ----------\n        at : any\n            Additional argument for the macro.\n\n        Returns\n        -------\n        any\n            The result of the macro operation.\n        \"\"\"\n        return self.execute_macro(self.lhs, self.rhs, at)\n\n    @staticmethod\n    def parse_pattern(pattern: MonomerPattern | ComplexPattern):\n        \"\"\"\n        Parse the monomer pattern to extract relevant information.\n\n        Parameters\n        ----------\n        pattern : MonomerPattern or ComplexPattern\n            The pattern to parse.\n\n        Returns\n        -------\n        tuple\n            A tuple containing the monomer, binding site, state, and compartment.\n        \"\"\"\n        mono = pattern.monomer\n        bsite = next(\n            (key for key, value in pattern.site_conditions.items() if value is None),\n            None,\n        )\n        state = {\n            key: value for key, value in pattern.site_conditions.items() if key != bsite\n        }\n        compartment = pattern.compartment\n        return mono, bsite, state, compartment\n</code></pre>"},{"location":"reference/#qspy.experimental.infix_macros.InfixMacro.__and__","title":"<code>__and__(at)</code>","text":"<p>Execute the macro logic using the &amp; operator.</p> <p>Parameters:</p> Name Type Description Default <code>at</code> <code>any</code> <p>Additional argument for the macro.</p> required <p>Returns:</p> Type Description <code>any</code> <p>The result of the macro operation.</p> Source code in <code>qspy\\experimental\\infix_macros.py</code> <pre><code>def __and__(self, at):\n    \"\"\"\n    Execute the macro logic using the &amp; operator.\n\n    Parameters\n    ----------\n    at : any\n        Additional argument for the macro.\n\n    Returns\n    -------\n    any\n        The result of the macro operation.\n    \"\"\"\n    return self.execute_macro(self.lhs, self.rhs, at)\n</code></pre>"},{"location":"reference/#qspy.experimental.infix_macros.InfixMacro.__init__","title":"<code>__init__(lhs=None, rhs=None)</code>","text":"<p>Initialize the infix macro with optional left and right sides.</p> <p>Parameters:</p> Name Type Description Default <code>lhs</code> <code>any</code> <p>The left-hand side of the infix operation.</p> <code>None</code> <code>rhs</code> <code>any</code> <p>The right-hand side of the infix operation.</p> <code>None</code> Source code in <code>qspy\\experimental\\infix_macros.py</code> <pre><code>def __init__(self, lhs=None, rhs=None):\n    \"\"\"\n    Initialize the infix macro with optional left and right sides.\n\n    Parameters\n    ----------\n    lhs : any, optional\n        The left-hand side of the infix operation.\n    rhs : any, optional\n        The right-hand side of the infix operation.\n    \"\"\"\n    self.lhs = lhs\n    self.rhs = rhs\n</code></pre>"},{"location":"reference/#qspy.experimental.infix_macros.InfixMacro.__mul__","title":"<code>__mul__(rhs)</code>","text":"<p>Capture the right-hand side operand for the infix macro.</p> <p>Parameters:</p> Name Type Description Default <code>rhs</code> <code>any</code> <p>The right-hand side operand.</p> required <p>Returns:</p> Type Description <code>InfixMacro</code> <p>The same instance with rhs set.</p> Source code in <code>qspy\\experimental\\infix_macros.py</code> <pre><code>def __mul__(self, rhs):\n    \"\"\"\n    Capture the right-hand side operand for the infix macro.\n\n    Parameters\n    ----------\n    rhs : any\n        The right-hand side operand.\n\n    Returns\n    -------\n    InfixMacro\n        The same instance with rhs set.\n    \"\"\"\n    self.rhs = rhs\n    return self\n</code></pre>"},{"location":"reference/#qspy.experimental.infix_macros.InfixMacro.__rmul__","title":"<code>__rmul__(lhs)</code>","text":"<p>Capture the left-hand side operand for the infix macro.</p> <p>Parameters:</p> Name Type Description Default <code>lhs</code> <code>any</code> <p>The left-hand side operand.</p> required <p>Returns:</p> Type Description <code>InfixMacro</code> <p>The same instance with lhs set.</p> Source code in <code>qspy\\experimental\\infix_macros.py</code> <pre><code>def __rmul__(self, lhs):\n    \"\"\"\n    Capture the left-hand side operand for the infix macro.\n\n    Parameters\n    ----------\n    lhs : any\n        The left-hand side operand.\n\n    Returns\n    -------\n    InfixMacro\n        The same instance with lhs set.\n    \"\"\"\n    self.lhs = lhs\n    return self\n</code></pre>"},{"location":"reference/#qspy.experimental.infix_macros.InfixMacro.execute_macro","title":"<code>execute_macro(lhs, rhs, at)</code>  <code>abstractmethod</code>","text":"<p>Abstract method to execute the macro logic.</p> <p>Parameters:</p> Name Type Description Default <code>lhs</code> <code>any</code> <p>The left-hand side operand.</p> required <code>rhs</code> <code>any</code> <p>The right-hand side operand.</p> required <code>at</code> <code>any</code> <p>Additional argument for the macro.</p> required <p>Returns:</p> Type Description <code>any</code> <p>The result of the macro operation.</p> Source code in <code>qspy\\experimental\\infix_macros.py</code> <pre><code>@abstractmethod\ndef execute_macro(self, lhs, rhs, at):\n    \"\"\"\n    Abstract method to execute the macro logic.\n\n    Parameters\n    ----------\n    lhs : any\n        The left-hand side operand.\n    rhs : any\n        The right-hand side operand.\n    at : any\n        Additional argument for the macro.\n\n    Returns\n    -------\n    any\n        The result of the macro operation.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#qspy.experimental.infix_macros.InfixMacro.parse_pattern","title":"<code>parse_pattern(pattern)</code>  <code>staticmethod</code>","text":"<p>Parse the monomer pattern to extract relevant information.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>MonomerPattern or ComplexPattern</code> <p>The pattern to parse.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the monomer, binding site, state, and compartment.</p> Source code in <code>qspy\\experimental\\infix_macros.py</code> <pre><code>@staticmethod\ndef parse_pattern(pattern: MonomerPattern | ComplexPattern):\n    \"\"\"\n    Parse the monomer pattern to extract relevant information.\n\n    Parameters\n    ----------\n    pattern : MonomerPattern or ComplexPattern\n        The pattern to parse.\n\n    Returns\n    -------\n    tuple\n        A tuple containing the monomer, binding site, state, and compartment.\n    \"\"\"\n    mono = pattern.monomer\n    bsite = next(\n        (key for key, value in pattern.site_conditions.items() if value is None),\n        None,\n    )\n    state = {\n        key: value for key, value in pattern.site_conditions.items() if key != bsite\n    }\n    compartment = pattern.compartment\n    return mono, bsite, state, compartment\n</code></pre>"},{"location":"reference/#qspy.experimental.functional_monomers","title":"<code>qspy.experimental.functional_monomers</code>","text":"<p>QSPy experimental functional monomers subpackage.</p> <p>Provides base classes, mixins, and macros for building and manipulating functional monomers, including support for binding, synthesis, degradation, and protein-specific behaviors.</p>"},{"location":"reference/#qspy.experimental.functional_monomers.protein","title":"<code>qspy.experimental.functional_monomers.protein</code>","text":"<p>Functional monomer protein classes and mixins for QSPy experimental API.</p> <p>Provides: - TurnoverMixin: mixin for synthesis and degradation reactions. - Ligand: class for ligand monomers with binding functionality. - Receptor: class for receptor monomers with orthosteric/allosteric binding and activation.</p>"},{"location":"reference/#qspy.experimental.functional_monomers.protein.Ligand","title":"<code>Ligand</code>","text":"<p>               Bases: <code>BindMixin</code>, <code>FunctionalMonomer</code></p> <p>Class representing a ligand monomer with binding functionality.</p> Source code in <code>qspy\\experimental\\functional_monomers\\protein.py</code> <pre><code>class Ligand(BindMixin, FunctionalMonomer):\n    \"\"\"\n    Class representing a ligand monomer with binding functionality.\n    \"\"\"\n\n    _sites = [\"b\"]\n    _functional_tag = PROTEIN.LIGAND\n    _base_state = {\"b\": None}\n\n    @property\n    def binding_site(self):\n        \"\"\"\n        Return the binding site for this ligand.\n\n        Returns\n        -------\n        str\n            The name of the binding site.\n        \"\"\"\n        return self._sites[0]\n\n    def binds_to(\n        self,\n        receptor: \"Receptor\",\n        r_site: str,\n        k_f: float | Parameter,\n        k_r: float | Parameter,\n        compartment: None | Compartment = None,\n    ):\n        \"\"\"\n        Create a reversible binding reaction between this ligand and a receptor.\n\n        Parameters\n        ----------\n        receptor : Receptor\n            The receptor to bind.\n        r_site : str\n            The binding site on the receptor.\n        k_f : float or Parameter\n            Forward rate constant.\n        k_r : float or Parameter\n            Reverse rate constant.\n        compartment : Compartment or None, optional\n            Compartment for the reaction (default: None).\n\n        Returns\n        -------\n        ComponentSet\n            PySB ComponentSet for the binding reaction.\n        \"\"\"\n        return self.binds(\n            self.binding_site, receptor, r_site, k_f, k_r, compartment=compartment\n        )\n\n    def concertedly_activates(self, receptor, k_f, k_r, compartment=None):\n        \"\"\"\n        Create a concerted activation reaction for a receptor by this ligand.\n\n        Parameters\n        ----------\n        receptor : Receptor\n            The receptor to activate.\n        k_f : float or Parameter\n            Forward rate constant.\n        k_r : float or Parameter\n            Reverse rate constant.\n        compartment : Compartment or None, optional\n            Compartment for the reaction (default: None).\n\n        Returns\n        -------\n        ComponentSet\n            PySB ComponentSet for the concerted activation reaction.\n        \"\"\"\n        return receptor.concertedly_activated_by(self, k_f, k_r, compartment)\n</code></pre>"},{"location":"reference/#qspy.experimental.functional_monomers.protein.Ligand.binding_site","title":"<code>binding_site</code>  <code>property</code>","text":"<p>Return the binding site for this ligand.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the binding site.</p>"},{"location":"reference/#qspy.experimental.functional_monomers.protein.Ligand.binds_to","title":"<code>binds_to(receptor, r_site, k_f, k_r, compartment=None)</code>","text":"<p>Create a reversible binding reaction between this ligand and a receptor.</p> <p>Parameters:</p> Name Type Description Default <code>receptor</code> <code>Receptor</code> <p>The receptor to bind.</p> required <code>r_site</code> <code>str</code> <p>The binding site on the receptor.</p> required <code>k_f</code> <code>float or Parameter</code> <p>Forward rate constant.</p> required <code>k_r</code> <code>float or Parameter</code> <p>Reverse rate constant.</p> required <code>compartment</code> <code>Compartment or None</code> <p>Compartment for the reaction (default: None).</p> <code>None</code> <p>Returns:</p> Type Description <code>ComponentSet</code> <p>PySB ComponentSet for the binding reaction.</p> Source code in <code>qspy\\experimental\\functional_monomers\\protein.py</code> <pre><code>def binds_to(\n    self,\n    receptor: \"Receptor\",\n    r_site: str,\n    k_f: float | Parameter,\n    k_r: float | Parameter,\n    compartment: None | Compartment = None,\n):\n    \"\"\"\n    Create a reversible binding reaction between this ligand and a receptor.\n\n    Parameters\n    ----------\n    receptor : Receptor\n        The receptor to bind.\n    r_site : str\n        The binding site on the receptor.\n    k_f : float or Parameter\n        Forward rate constant.\n    k_r : float or Parameter\n        Reverse rate constant.\n    compartment : Compartment or None, optional\n        Compartment for the reaction (default: None).\n\n    Returns\n    -------\n    ComponentSet\n        PySB ComponentSet for the binding reaction.\n    \"\"\"\n    return self.binds(\n        self.binding_site, receptor, r_site, k_f, k_r, compartment=compartment\n    )\n</code></pre>"},{"location":"reference/#qspy.experimental.functional_monomers.protein.Ligand.concertedly_activates","title":"<code>concertedly_activates(receptor, k_f, k_r, compartment=None)</code>","text":"<p>Create a concerted activation reaction for a receptor by this ligand.</p> <p>Parameters:</p> Name Type Description Default <code>receptor</code> <code>Receptor</code> <p>The receptor to activate.</p> required <code>k_f</code> <code>float or Parameter</code> <p>Forward rate constant.</p> required <code>k_r</code> <code>float or Parameter</code> <p>Reverse rate constant.</p> required <code>compartment</code> <code>Compartment or None</code> <p>Compartment for the reaction (default: None).</p> <code>None</code> <p>Returns:</p> Type Description <code>ComponentSet</code> <p>PySB ComponentSet for the concerted activation reaction.</p> Source code in <code>qspy\\experimental\\functional_monomers\\protein.py</code> <pre><code>def concertedly_activates(self, receptor, k_f, k_r, compartment=None):\n    \"\"\"\n    Create a concerted activation reaction for a receptor by this ligand.\n\n    Parameters\n    ----------\n    receptor : Receptor\n        The receptor to activate.\n    k_f : float or Parameter\n        Forward rate constant.\n    k_r : float or Parameter\n        Reverse rate constant.\n    compartment : Compartment or None, optional\n        Compartment for the reaction (default: None).\n\n    Returns\n    -------\n    ComponentSet\n        PySB ComponentSet for the concerted activation reaction.\n    \"\"\"\n    return receptor.concertedly_activated_by(self, k_f, k_r, compartment)\n</code></pre>"},{"location":"reference/#qspy.experimental.functional_monomers.protein.Receptor","title":"<code>Receptor</code>","text":"<p>               Bases: <code>BindMixin</code>, <code>TurnoverMixin</code>, <code>FunctionalMonomer</code></p> <p>Class representing a receptor monomer with orthosteric/allosteric binding and activation.</p> Source code in <code>qspy\\experimental\\functional_monomers\\protein.py</code> <pre><code>class Receptor(BindMixin, TurnoverMixin, FunctionalMonomer):\n    \"\"\"\n    Class representing a receptor monomer with orthosteric/allosteric binding and activation.\n    \"\"\"\n\n    _sites = [\"b_ortho\", \"b_allo\", \"active\"]\n    _site_states = {\"active\": [False, True]}\n    _functional_tag = PROTEIN.RECEPTOR\n    _base_state = {\"b_ortho\": None, \"b_allo\": None, \"active\": False}\n    _inactive_state = {\"active\": False}\n    _active_state = {\"active\": True}\n\n    @property\n    def binding_sites(self):\n        \"\"\"\n        Return the orthosteric and allosteric binding sites.\n\n        Returns\n        -------\n        list\n            List of binding site names.\n        \"\"\"\n        return self._sites[:2]\n\n    @property\n    def orthosteric_site(self):\n        \"\"\"\n        Return the orthosteric binding site.\n\n        Returns\n        -------\n        str\n            Name of the orthosteric site.\n        \"\"\"\n        return self._sites[0]\n\n    @property\n    def allosteric_site(self):\n        \"\"\"\n        Return the allosteric binding site.\n\n        Returns\n        -------\n        str\n            Name of the allosteric site.\n        \"\"\"\n        return self._sites[1]\n\n    @property\n    def inactive(self):\n        \"\"\"\n        Return the inactive state dictionary.\n\n        Returns\n        -------\n        dict\n            Dictionary representing the inactive state.\n        \"\"\"\n        return self._inactive_state\n\n    @property\n    def active(self):\n        \"\"\"\n        Return the active state dictionary.\n\n        Returns\n        -------\n        dict\n            Dictionary representing the active state.\n        \"\"\"\n        return self._active_state\n\n    def _binds_orthosteric(\n        self,\n        ligand: Ligand,\n        k_f: float | Parameter,\n        k_r: float | Parameter,\n        compartment: None | Compartment = None,\n    ):\n        \"\"\"\n        Create a reversible binding reaction at the orthosteric site.\n\n        Parameters\n        ----------\n        ligand : Ligand\n            The ligand to bind.\n        k_f : float or Parameter\n            Forward rate constant.\n        k_r : float or Parameter\n            Reverse rate constant.\n        compartment : Compartment or None, optional\n            Compartment for the reaction (default: None).\n\n        Returns\n        -------\n        ComponentSet\n            PySB ComponentSet for the binding reaction.\n        \"\"\"\n        return self.binds(\n            self.orthosteric_site,\n            ligand,\n            ligand.binding_site,\n            k_f,\n            k_r,\n            compartment=compartment,\n        )\n\n    def _binds_allosteric(self, ligand: Ligand, k_f, k_r, compartment=None):\n        \"\"\"\n        Create a reversible binding reaction at the allosteric site.\n\n        Parameters\n        ----------\n        ligand : Ligand\n            The ligand to bind.\n        k_f : float or Parameter\n            Forward rate constant.\n        k_r : float or Parameter\n            Reverse rate constant.\n        compartment : Compartment or None, optional\n            Compartment for the reaction (default: None).\n\n        Returns\n        -------\n        ComponentSet\n            PySB ComponentSet for the binding reaction.\n        \"\"\"\n        return self.binds(\n            self.allosteric_site,\n            ligand,\n            ligand.binding_site,\n            k_f,\n            k_r,\n            compartment=compartment,\n        )\n\n    def bound_by(self, ligand, k_f, k_r, location=\"orthosteric\", compartment=None):\n        \"\"\"\n        Create a reversible binding reaction at the specified site.\n\n        Parameters\n        ----------\n        ligand : Ligand\n            The ligand to bind.\n        k_f : float or Parameter\n            Forward rate constant.\n        k_r : float or Parameter\n            Reverse rate constant.\n        location : str, optional\n            \"orthosteric\" or \"allosteric\" (default: \"orthosteric\").\n        compartment : Compartment or None, optional\n            Compartment for the reaction (default: None).\n\n        Returns\n        -------\n        ComponentSet\n            PySB ComponentSet for the binding reaction.\n        \"\"\"\n        if location == \"orthosteric\":\n            return self._binds_orthosteric(ligand, k_f, k_r, compartment=compartment)\n        elif location == \"allosteric\":\n            return self._binds_allosteric(ligand, k_f, k_r, compartment=compartment)\n\n    def concertedly_activated_by(self, ligand: Ligand, k_f, k_r, compartment=None):\n        \"\"\"\n        Create a concerted activation reaction for this receptor by a ligand.\n\n        Parameters\n        ----------\n        ligand : Ligand\n            The ligand to activate this receptor.\n        k_f : float or Parameter\n            Forward rate constant.\n        k_r : float or Parameter\n            Reverse rate constant.\n        compartment : Compartment or None, optional\n            Compartment for the reaction (default: None).\n\n        Returns\n        -------\n        ComponentSet\n            PySB ComponentSet for the concerted activation reaction.\n        \"\"\"\n        return activate_concerted(\n            ligand,\n            ligand.binding_site,\n            self,\n            self.orthosteric_site,\n            self.inactive,\n            self.active,\n            [k_f, k_r],\n            compartment=compartment,\n        )\n</code></pre>"},{"location":"reference/#qspy.experimental.functional_monomers.protein.Receptor.active","title":"<code>active</code>  <code>property</code>","text":"<p>Return the active state dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representing the active state.</p>"},{"location":"reference/#qspy.experimental.functional_monomers.protein.Receptor.allosteric_site","title":"<code>allosteric_site</code>  <code>property</code>","text":"<p>Return the allosteric binding site.</p> <p>Returns:</p> Type Description <code>str</code> <p>Name of the allosteric site.</p>"},{"location":"reference/#qspy.experimental.functional_monomers.protein.Receptor.binding_sites","title":"<code>binding_sites</code>  <code>property</code>","text":"<p>Return the orthosteric and allosteric binding sites.</p> <p>Returns:</p> Type Description <code>list</code> <p>List of binding site names.</p>"},{"location":"reference/#qspy.experimental.functional_monomers.protein.Receptor.inactive","title":"<code>inactive</code>  <code>property</code>","text":"<p>Return the inactive state dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representing the inactive state.</p>"},{"location":"reference/#qspy.experimental.functional_monomers.protein.Receptor.orthosteric_site","title":"<code>orthosteric_site</code>  <code>property</code>","text":"<p>Return the orthosteric binding site.</p> <p>Returns:</p> Type Description <code>str</code> <p>Name of the orthosteric site.</p>"},{"location":"reference/#qspy.experimental.functional_monomers.protein.Receptor.bound_by","title":"<code>bound_by(ligand, k_f, k_r, location='orthosteric', compartment=None)</code>","text":"<p>Create a reversible binding reaction at the specified site.</p> <p>Parameters:</p> Name Type Description Default <code>ligand</code> <code>Ligand</code> <p>The ligand to bind.</p> required <code>k_f</code> <code>float or Parameter</code> <p>Forward rate constant.</p> required <code>k_r</code> <code>float or Parameter</code> <p>Reverse rate constant.</p> required <code>location</code> <code>str</code> <p>\"orthosteric\" or \"allosteric\" (default: \"orthosteric\").</p> <code>'orthosteric'</code> <code>compartment</code> <code>Compartment or None</code> <p>Compartment for the reaction (default: None).</p> <code>None</code> <p>Returns:</p> Type Description <code>ComponentSet</code> <p>PySB ComponentSet for the binding reaction.</p> Source code in <code>qspy\\experimental\\functional_monomers\\protein.py</code> <pre><code>def bound_by(self, ligand, k_f, k_r, location=\"orthosteric\", compartment=None):\n    \"\"\"\n    Create a reversible binding reaction at the specified site.\n\n    Parameters\n    ----------\n    ligand : Ligand\n        The ligand to bind.\n    k_f : float or Parameter\n        Forward rate constant.\n    k_r : float or Parameter\n        Reverse rate constant.\n    location : str, optional\n        \"orthosteric\" or \"allosteric\" (default: \"orthosteric\").\n    compartment : Compartment or None, optional\n        Compartment for the reaction (default: None).\n\n    Returns\n    -------\n    ComponentSet\n        PySB ComponentSet for the binding reaction.\n    \"\"\"\n    if location == \"orthosteric\":\n        return self._binds_orthosteric(ligand, k_f, k_r, compartment=compartment)\n    elif location == \"allosteric\":\n        return self._binds_allosteric(ligand, k_f, k_r, compartment=compartment)\n</code></pre>"},{"location":"reference/#qspy.experimental.functional_monomers.protein.Receptor.concertedly_activated_by","title":"<code>concertedly_activated_by(ligand, k_f, k_r, compartment=None)</code>","text":"<p>Create a concerted activation reaction for this receptor by a ligand.</p> <p>Parameters:</p> Name Type Description Default <code>ligand</code> <code>Ligand</code> <p>The ligand to activate this receptor.</p> required <code>k_f</code> <code>float or Parameter</code> <p>Forward rate constant.</p> required <code>k_r</code> <code>float or Parameter</code> <p>Reverse rate constant.</p> required <code>compartment</code> <code>Compartment or None</code> <p>Compartment for the reaction (default: None).</p> <code>None</code> <p>Returns:</p> Type Description <code>ComponentSet</code> <p>PySB ComponentSet for the concerted activation reaction.</p> Source code in <code>qspy\\experimental\\functional_monomers\\protein.py</code> <pre><code>def concertedly_activated_by(self, ligand: Ligand, k_f, k_r, compartment=None):\n    \"\"\"\n    Create a concerted activation reaction for this receptor by a ligand.\n\n    Parameters\n    ----------\n    ligand : Ligand\n        The ligand to activate this receptor.\n    k_f : float or Parameter\n        Forward rate constant.\n    k_r : float or Parameter\n        Reverse rate constant.\n    compartment : Compartment or None, optional\n        Compartment for the reaction (default: None).\n\n    Returns\n    -------\n    ComponentSet\n        PySB ComponentSet for the concerted activation reaction.\n    \"\"\"\n    return activate_concerted(\n        ligand,\n        ligand.binding_site,\n        self,\n        self.orthosteric_site,\n        self.inactive,\n        self.active,\n        [k_f, k_r],\n        compartment=compartment,\n    )\n</code></pre>"},{"location":"reference/#qspy.experimental.functional_monomers.protein.TurnoverMixin","title":"<code>TurnoverMixin</code>","text":"<p>               Bases: <code>DegradeMixin</code>, <code>SynthesizeMixin</code></p> <p>Mixin class providing a turnover() method for synthesis and degradation reactions.</p> Source code in <code>qspy\\experimental\\functional_monomers\\protein.py</code> <pre><code>class TurnoverMixin(DegradeMixin, SynthesizeMixin):\n    \"\"\"\n    Mixin class providing a turnover() method for synthesis and degradation reactions.\n    \"\"\"\n\n    def turnover(\n        self,\n        k_syn: float | Parameter,\n        k_deg: float | Parameter,\n        compartment: None | Compartment = None,\n    ) -&gt; ComponentSet:\n        \"\"\"\n        Create synthesis and degradation reactions for this monomer.\n\n        Parameters\n        ----------\n        k_syn : float or Parameter\n            Synthesis rate constant.\n        k_deg : float or Parameter\n            Degradation rate constant.\n        compartment : Compartment or None, optional\n            Compartment for the reactions (default: None).\n\n        Returns\n        -------\n        ComponentSet\n            Combined PySB ComponentSet for synthesis and degradation.\n        \"\"\"\n        components_syn = self.synthesized(k_syn, compartment=compartment)\n        components_deg = self.degraded({}, k_deg, compartment=compartment)\n        return components_syn | components_deg\n</code></pre>"},{"location":"reference/#qspy.experimental.functional_monomers.protein.TurnoverMixin.turnover","title":"<code>turnover(k_syn, k_deg, compartment=None)</code>","text":"<p>Create synthesis and degradation reactions for this monomer.</p> <p>Parameters:</p> Name Type Description Default <code>k_syn</code> <code>float or Parameter</code> <p>Synthesis rate constant.</p> required <code>k_deg</code> <code>float or Parameter</code> <p>Degradation rate constant.</p> required <code>compartment</code> <code>Compartment or None</code> <p>Compartment for the reactions (default: None).</p> <code>None</code> <p>Returns:</p> Type Description <code>ComponentSet</code> <p>Combined PySB ComponentSet for synthesis and degradation.</p> Source code in <code>qspy\\experimental\\functional_monomers\\protein.py</code> <pre><code>def turnover(\n    self,\n    k_syn: float | Parameter,\n    k_deg: float | Parameter,\n    compartment: None | Compartment = None,\n) -&gt; ComponentSet:\n    \"\"\"\n    Create synthesis and degradation reactions for this monomer.\n\n    Parameters\n    ----------\n    k_syn : float or Parameter\n        Synthesis rate constant.\n    k_deg : float or Parameter\n        Degradation rate constant.\n    compartment : Compartment or None, optional\n        Compartment for the reactions (default: None).\n\n    Returns\n    -------\n    ComponentSet\n        Combined PySB ComponentSet for synthesis and degradation.\n    \"\"\"\n    components_syn = self.synthesized(k_syn, compartment=compartment)\n    components_deg = self.degraded({}, k_deg, compartment=compartment)\n    return components_syn | components_deg\n</code></pre>"},{"location":"reference/#qspy.experimental.functional_monomers.base","title":"<code>qspy.experimental.functional_monomers.base</code>","text":"<p>FunctionalMonomer base classes and mixins for QSPy experimental functional monomer API.</p> <p>Provides: - FunctionalMonomer: base class for monomers with functional tags and base states. - BindMixin: mixin for binding macro methods. - SynthesizeMixin: mixin for synthesis macro methods. - DegradeMixin: mixin for degradation macro methods.</p>"},{"location":"reference/#qspy.experimental.functional_monomers.base.BindMixin","title":"<code>BindMixin</code>","text":"<p>Mixin class providing a binds() method for binding reactions.</p> Source code in <code>qspy\\experimental\\functional_monomers\\base.py</code> <pre><code>class BindMixin:\n    \"\"\"\n    Mixin class providing a binds() method for binding reactions.\n    \"\"\"\n\n    def binds(\n        self,\n        site: str,\n        other: Monomer | MonomerPattern | FunctionalMonomer,\n        other_site: str,\n        k_f: float | Parameter,\n        k_r: float | Parameter,\n        compartment: None | Compartment = None,\n    ) -&gt; ComponentSet:\n        \"\"\"\n        Create a reversible binding reaction between this monomer and another.\n\n        Parameters\n        ----------\n        site : str\n            Binding site on this monomer.\n        other : Monomer, MonomerPattern, or FunctionalMonomer\n            The other monomer or pattern to bind.\n        other_site : str\n            Binding site on the other monomer.\n        k_f : float or Parameter\n            Forward rate constant.\n        k_r : float or Parameter\n            Reverse rate constant.\n        compartment : Compartment or None, optional\n            Compartment for the reaction (default: None).\n\n        Returns\n        -------\n        ComponentSet\n            PySB ComponentSet for the binding reaction.\n        \"\"\"\n        if compartment is None:\n            return bind(self, site, other, other_site, klist=[k_f, k_r])\n        else:\n            return bind(\n                _check_for_monomer(self, compartment),\n                site,\n                _check_for_monomer(other, compartment),\n                other_site,\n                klist=[k_f, k_r],\n            )\n</code></pre>"},{"location":"reference/#qspy.experimental.functional_monomers.base.BindMixin.binds","title":"<code>binds(site, other, other_site, k_f, k_r, compartment=None)</code>","text":"<p>Create a reversible binding reaction between this monomer and another.</p> <p>Parameters:</p> Name Type Description Default <code>site</code> <code>str</code> <p>Binding site on this monomer.</p> required <code>other</code> <code>Monomer, MonomerPattern, or FunctionalMonomer</code> <p>The other monomer or pattern to bind.</p> required <code>other_site</code> <code>str</code> <p>Binding site on the other monomer.</p> required <code>k_f</code> <code>float or Parameter</code> <p>Forward rate constant.</p> required <code>k_r</code> <code>float or Parameter</code> <p>Reverse rate constant.</p> required <code>compartment</code> <code>Compartment or None</code> <p>Compartment for the reaction (default: None).</p> <code>None</code> <p>Returns:</p> Type Description <code>ComponentSet</code> <p>PySB ComponentSet for the binding reaction.</p> Source code in <code>qspy\\experimental\\functional_monomers\\base.py</code> <pre><code>def binds(\n    self,\n    site: str,\n    other: Monomer | MonomerPattern | FunctionalMonomer,\n    other_site: str,\n    k_f: float | Parameter,\n    k_r: float | Parameter,\n    compartment: None | Compartment = None,\n) -&gt; ComponentSet:\n    \"\"\"\n    Create a reversible binding reaction between this monomer and another.\n\n    Parameters\n    ----------\n    site : str\n        Binding site on this monomer.\n    other : Monomer, MonomerPattern, or FunctionalMonomer\n        The other monomer or pattern to bind.\n    other_site : str\n        Binding site on the other monomer.\n    k_f : float or Parameter\n        Forward rate constant.\n    k_r : float or Parameter\n        Reverse rate constant.\n    compartment : Compartment or None, optional\n        Compartment for the reaction (default: None).\n\n    Returns\n    -------\n    ComponentSet\n        PySB ComponentSet for the binding reaction.\n    \"\"\"\n    if compartment is None:\n        return bind(self, site, other, other_site, klist=[k_f, k_r])\n    else:\n        return bind(\n            _check_for_monomer(self, compartment),\n            site,\n            _check_for_monomer(other, compartment),\n            other_site,\n            klist=[k_f, k_r],\n        )\n</code></pre>"},{"location":"reference/#qspy.experimental.functional_monomers.base.DegradeMixin","title":"<code>DegradeMixin</code>","text":"<p>Mixin class providing a degraded() method for degradation reactions.</p> Source code in <code>qspy\\experimental\\functional_monomers\\base.py</code> <pre><code>class DegradeMixin:\n    \"\"\"\n    Mixin class providing a degraded() method for degradation reactions.\n    \"\"\"\n\n    def degraded(\n        self,\n        state: dict,\n        k_deg: float | Parameter,\n        compartment: None | Compartment = None,\n    ):\n        \"\"\"\n        Create a degradation reaction for this monomer in a given state.\n\n        Parameters\n        ----------\n        state : dict\n            State assignment for the monomer.\n        k_deg : float or Parameter\n            Degradation rate constant.\n        compartment : Compartment or None, optional\n            Compartment for the reaction (default: None).\n\n        Returns\n        -------\n        ComponentSet\n            PySB ComponentSet for the degradation reaction.\n        \"\"\"\n        if compartment is None:\n            return degrade(\n                self(**state),\n                k_deg,\n            )\n        else:\n            return degrade(\n                _check_for_monomer(self(**state), compartment),\n                k_deg,\n            )\n</code></pre>"},{"location":"reference/#qspy.experimental.functional_monomers.base.DegradeMixin.degraded","title":"<code>degraded(state, k_deg, compartment=None)</code>","text":"<p>Create a degradation reaction for this monomer in a given state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>dict</code> <p>State assignment for the monomer.</p> required <code>k_deg</code> <code>float or Parameter</code> <p>Degradation rate constant.</p> required <code>compartment</code> <code>Compartment or None</code> <p>Compartment for the reaction (default: None).</p> <code>None</code> <p>Returns:</p> Type Description <code>ComponentSet</code> <p>PySB ComponentSet for the degradation reaction.</p> Source code in <code>qspy\\experimental\\functional_monomers\\base.py</code> <pre><code>def degraded(\n    self,\n    state: dict,\n    k_deg: float | Parameter,\n    compartment: None | Compartment = None,\n):\n    \"\"\"\n    Create a degradation reaction for this monomer in a given state.\n\n    Parameters\n    ----------\n    state : dict\n        State assignment for the monomer.\n    k_deg : float or Parameter\n        Degradation rate constant.\n    compartment : Compartment or None, optional\n        Compartment for the reaction (default: None).\n\n    Returns\n    -------\n    ComponentSet\n        PySB ComponentSet for the degradation reaction.\n    \"\"\"\n    if compartment is None:\n        return degrade(\n            self(**state),\n            k_deg,\n        )\n    else:\n        return degrade(\n            _check_for_monomer(self(**state), compartment),\n            k_deg,\n        )\n</code></pre>"},{"location":"reference/#qspy.experimental.functional_monomers.base.FunctionalMonomer","title":"<code>FunctionalMonomer</code>","text":"<p>               Bases: <code>Monomer</code></p> <p>Base class for functional monomers in QSPy.</p> <p>Adds support for binding sites, site states, functional tags, and a base state.</p> Source code in <code>qspy\\experimental\\functional_monomers\\base.py</code> <pre><code>class FunctionalMonomer(Monomer):\n    \"\"\"\n    Base class for functional monomers in QSPy.\n\n    Adds support for binding sites, site states, functional tags, and a base state.\n    \"\"\"\n\n    _sites = None\n    _site_states = None\n    _functional_tag = None\n    _base_state = dict()\n\n    def __init__(self, name: str):\n        \"\"\"\n        Initialize a FunctionalMonomer.\n\n        Parameters\n        ----------\n        name : str\n            Name of the monomer.\n        \"\"\"\n        super(FunctionalMonomer, self).__init__(name, self._sites, self._site_states)\n        self @= self._functional_tag\n        return\n\n    @property\n    def binding_sites(self) -&gt; list:\n        \"\"\"\n        List of binding sites for this monomer.\n\n        Returns\n        -------\n        list\n            List of binding site names.\n        \"\"\"\n        return self._sites\n\n    @property\n    def states(self) -&gt; dict:\n        \"\"\"\n        Dictionary of site states for this monomer.\n\n        Returns\n        -------\n        dict\n            Dictionary mapping site names to possible states.\n        \"\"\"\n        return self._site_states\n\n    @property\n    def base_state(self) -&gt; dict:\n        \"\"\"\n        Dictionary of base state values for this monomer.\n\n        Returns\n        -------\n        dict\n            Dictionary of base state assignments.\n        \"\"\"\n        return self._base_state\n</code></pre>"},{"location":"reference/#qspy.experimental.functional_monomers.base.FunctionalMonomer.base_state","title":"<code>base_state</code>  <code>property</code>","text":"<p>Dictionary of base state values for this monomer.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of base state assignments.</p>"},{"location":"reference/#qspy.experimental.functional_monomers.base.FunctionalMonomer.binding_sites","title":"<code>binding_sites</code>  <code>property</code>","text":"<p>List of binding sites for this monomer.</p> <p>Returns:</p> Type Description <code>list</code> <p>List of binding site names.</p>"},{"location":"reference/#qspy.experimental.functional_monomers.base.FunctionalMonomer.states","title":"<code>states</code>  <code>property</code>","text":"<p>Dictionary of site states for this monomer.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary mapping site names to possible states.</p>"},{"location":"reference/#qspy.experimental.functional_monomers.base.FunctionalMonomer.__init__","title":"<code>__init__(name)</code>","text":"<p>Initialize a FunctionalMonomer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the monomer.</p> required Source code in <code>qspy\\experimental\\functional_monomers\\base.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"\n    Initialize a FunctionalMonomer.\n\n    Parameters\n    ----------\n    name : str\n        Name of the monomer.\n    \"\"\"\n    super(FunctionalMonomer, self).__init__(name, self._sites, self._site_states)\n    self @= self._functional_tag\n    return\n</code></pre>"},{"location":"reference/#qspy.experimental.functional_monomers.base.SynthesizeMixin","title":"<code>SynthesizeMixin</code>","text":"<p>Mixin class providing a synthesized() method for synthesis reactions.</p> Source code in <code>qspy\\experimental\\functional_monomers\\base.py</code> <pre><code>class SynthesizeMixin:\n    \"\"\"\n    Mixin class providing a synthesized() method for synthesis reactions.\n    \"\"\"\n\n    def synthesized(\n        self, k_syn: float | Parameter, compartment: None | Compartment = None\n    ) -&gt; ComponentSet:\n        \"\"\"\n        Create a synthesis reaction for this monomer.\n\n        Parameters\n        ----------\n        k_syn : float or Parameter\n            Synthesis rate constant.\n        compartment : Compartment or None, optional\n            Compartment for the reaction (default: None).\n\n        Returns\n        -------\n        ComponentSet\n            PySB ComponentSet for the synthesis reaction.\n        \"\"\"\n        if compartment is None:\n            return synthesize(\n                self(**self.base_state),\n                k_syn,\n            )\n        else:\n            return synthesize(\n                _check_for_monomer(self(**self.base_state), compartment),\n                k_syn,\n            )\n</code></pre>"},{"location":"reference/#qspy.experimental.functional_monomers.base.SynthesizeMixin.synthesized","title":"<code>synthesized(k_syn, compartment=None)</code>","text":"<p>Create a synthesis reaction for this monomer.</p> <p>Parameters:</p> Name Type Description Default <code>k_syn</code> <code>float or Parameter</code> <p>Synthesis rate constant.</p> required <code>compartment</code> <code>Compartment or None</code> <p>Compartment for the reaction (default: None).</p> <code>None</code> <p>Returns:</p> Type Description <code>ComponentSet</code> <p>PySB ComponentSet for the synthesis reaction.</p> Source code in <code>qspy\\experimental\\functional_monomers\\base.py</code> <pre><code>def synthesized(\n    self, k_syn: float | Parameter, compartment: None | Compartment = None\n) -&gt; ComponentSet:\n    \"\"\"\n    Create a synthesis reaction for this monomer.\n\n    Parameters\n    ----------\n    k_syn : float or Parameter\n        Synthesis rate constant.\n    compartment : Compartment or None, optional\n        Compartment for the reaction (default: None).\n\n    Returns\n    -------\n    ComponentSet\n        PySB ComponentSet for the synthesis reaction.\n    \"\"\"\n    if compartment is None:\n        return synthesize(\n            self(**self.base_state),\n            k_syn,\n        )\n    else:\n        return synthesize(\n            _check_for_monomer(self(**self.base_state), compartment),\n            k_syn,\n        )\n</code></pre>"},{"location":"reference/#qspy.experimental.functional_monomers.macros","title":"<code>qspy.experimental.functional_monomers.macros</code>","text":"<p>Functional monomer macros for QSPy experimental API.</p> <p>Provides: - activate_concerted: macro for concerted activation of a receptor by a ligand.</p>"},{"location":"reference/#qspy.experimental.functional_monomers.macros.activate_concerted","title":"<code>activate_concerted(ligand, l_site, receptor, r_site, inactive_state, active_state, k_list, compartment=None)</code>","text":"<p>Generate a concerted activation reaction for a receptor by a ligand.</p> <p>This macro creates a reversible binding rule where a ligand binds to a receptor, and the receptor transitions from an inactive state to an active state as part of the binding event.</p> <p>Parameters:</p> Name Type Description Default <code>ligand</code> <code>Monomer or MonomerPattern</code> <p>The ligand species or pattern.</p> required <code>l_site</code> <code>str</code> <p>The binding site on the ligand.</p> required <code>receptor</code> <code>Monomer or MonomerPattern</code> <p>The receptor species or pattern.</p> required <code>r_site</code> <code>str</code> <p>The binding site on the receptor.</p> required <code>inactive_state</code> <code>dict</code> <p>Dictionary specifying the inactive state of the receptor.</p> required <code>active_state</code> <code>dict</code> <p>Dictionary specifying the active state of the receptor.</p> required <code>k_list</code> <code>list</code> <p>List of rate constants [k_f, k_r] for forward and reverse reactions.</p> required <code>compartment</code> <code>Compartment or None</code> <p>The compartment in which the reaction occurs (default: None).</p> <code>None</code> <p>Returns:</p> Type Description <code>ComponentSet</code> <p>The generated components, including the reversible activation Rule.</p> <p>Examples:</p> <p>Concerted activation of a receptor by a ligand::</p> <pre><code>Model()\nMonomer('Ligand', ['b'])\nMonomer('Receptor', ['b', 'state'], {'state': ['inactive', 'active']})\nactivate_concerted(\n    Ligand, 'b', Receptor, 'b',\n    {'state': 'inactive'}, {'state': 'active'},\n    [1e-3, 1e-3]\n)\n</code></pre> Source code in <code>qspy\\experimental\\functional_monomers\\macros.py</code> <pre><code>def activate_concerted(\n    ligand: Monomer | MonomerPattern,\n    l_site: str,\n    receptor: Monomer | MonomerPattern,\n    r_site: str,\n    inactive_state: dict,\n    active_state: dict,\n    k_list: list,\n    compartment: None | Compartment = None,\n):\n    \"\"\"\n    Generate a concerted activation reaction for a receptor by a ligand.\n\n    This macro creates a reversible binding rule where a ligand binds to a receptor,\n    and the receptor transitions from an inactive state to an active state as part of the binding event.\n\n    Parameters\n    ----------\n    ligand : Monomer or MonomerPattern\n        The ligand species or pattern.\n    l_site : str\n        The binding site on the ligand.\n    receptor : Monomer or MonomerPattern\n        The receptor species or pattern.\n    r_site : str\n        The binding site on the receptor.\n    inactive_state : dict\n        Dictionary specifying the inactive state of the receptor.\n    active_state : dict\n        Dictionary specifying the active state of the receptor.\n    k_list : list\n        List of rate constants [k_f, k_r] for forward and reverse reactions.\n    compartment : Compartment or None, optional\n        The compartment in which the reaction occurs (default: None).\n\n    Returns\n    -------\n    ComponentSet\n        The generated components, including the reversible activation Rule.\n\n    Examples\n    --------\n    Concerted activation of a receptor by a ligand::\n\n        Model()\n        Monomer('Ligand', ['b'])\n        Monomer('Receptor', ['b', 'state'], {'state': ['inactive', 'active']})\n        activate_concerted(\n            Ligand, 'b', Receptor, 'b',\n            {'state': 'inactive'}, {'state': 'active'},\n            [1e-3, 1e-3]\n        )\n\n    \"\"\"\n    _verify_sites(ligand, l_site)\n    _verify_sites(receptor, [r_site] + list(active_state.keys()))\n    def activate_concerted_name_func(rule_expression):\n        cps = rule_expression.reactant_pattern.complex_patterns\n        if compartment is not None:\n            comp_name = compartment.name\n            return \"_\".join(_complex_pattern_label(cp) for cp in cps).join(\n                [\"_\", comp_name]\n            )\n        else:\n            return \"_\".join(_complex_pattern_label(cp) for cp in cps)\n\n    s1_free = ligand(**{l_site: None})\n    s1_bound = ligand(**{l_site: 1})\n    s2_i = receptor(**{r_site: None}.update(inactive_state))\n    s2_a = receptor(**{r_site: 1}.update(active_state))\n    if compartment is not None:\n        s1_free = _check_for_monomer(s1_free, compartment)\n        s1_bound = _check_for_monomer(s1_bound, compartment)\n        s2_i = _check_for_monomer(s2_i, compartment)\n        s2_a = _check_for_monomer(s2_a, compartment)\n\n    return _macro_rule(\n        \"activate_concerted\",\n        s1_free + s2_i | s1_bound % s2_a,\n        k_list,\n        [\"k_f\", \"k_r\"],\n        name_func=activate_concerted_name_func,\n    )\n</code></pre>"},{"location":"related-software/","title":"Related Software","text":"<p>There are a variety of pharmacological modeling tools. Below is a (likely non-exhaustive) list of such tools categorized into free/open-source and commercial/proprietary tools, and grouped by programming language where applicable.</p>"},{"location":"related-software/#free-open-source-tools","title":"Free &amp; Open-Source Tools","text":""},{"location":"related-software/#python-based-solutions","title":"Python-Based Solutions","text":"<ul> <li>PharmPy \u2013 A Python-based toolkit for nonlinear mixed-effects modeling, focused on PK/PD applications. (GPL-3.0)</li> <li>scipion-pkpd \u2013 A Python plugin for PK/PD modeling within the Scipion workflow engine. (GPL-3.0)</li> <li>Chi \u2013 A Python-based pharmacometrics modeling tool. (BSD 3-Clause)</li> </ul>"},{"location":"related-software/#r-based-solutions","title":"R-Based Solutions","text":"<ul> <li>PKPDsim \u2013 A package for PK/PD simulations supporting differential equations and stochastic models. (GPL-3.0)</li> <li>mrgsolve \u2013 A model simulation tool designed for population PK/PD analysis. (MIT License)</li> <li>nlme \u2013 A package for fitting nonlinear mixed-effects models, widely used in PK/PD analysis. (Part of R Base, freely available)</li> <li>nlmixr \u2013 A flexible platform for nonlinear mixed-effects modeling, specifically designed for PK/PD applications. (GPL-2.0)</li> <li>rxode2 \u2013 A powerful ODE-based solver for PK/PD and pharmacometrics simulations. (GPL-2.0)</li> <li>Ubiquity \u2013 A modeling framework primarily based in R, designed for PK/PD and systems pharmacology applications. (BSD 3-Clause)</li> </ul>"},{"location":"related-software/#cgui-based-solutions","title":"C++/GUI-Based Solutions","text":"<ul> <li>BioGears \u2013 A C++-based open-source human physiology simulation engine with a Java-based GUI. (Apache-2.0 License)</li> </ul>"},{"location":"related-software/#command-line-based","title":"Command-Line Based","text":"<ul> <li>GNU MCSim \u2013 A Monte Carlo simulation tool written in C that supports differential equation modeling and Bayesian inference. (GPL-2.0)</li> </ul>"},{"location":"related-software/#gui-based-solutions","title":"GUI-Based Solutions","text":"<ul> <li>Open Systems Pharmacology \u2013 A comprehensive open-source suite for PBPK and PK/PD modeling, including:</li> <li>PK-Sim \u2013 A tool for physiologically based pharmacokinetic (PBPK) modeling. (GPL-2.0)</li> <li>MoBi \u2013 A tool for mechanistic modeling, allowing integration of molecular and cellular processes. (GPL-2.0)</li> </ul>"},{"location":"related-software/#other-modeling-frameworks","title":"Other Modeling Frameworks","text":"<ul> <li>Heta Project \u2013 A modeling framework for Quantitative Systems Pharmacology (QSP) and Systems Biology.</li> </ul>"},{"location":"related-software/#commercial-proprietary-applications","title":"Commercial &amp; Proprietary Applications","text":"<ul> <li>NONMEM \u2013 Industry-standard software for nonlinear mixed-effects modeling, widely used in population PK/PD studies.</li> <li>Monolix \u2013 A powerful application for model-based PK/PD analysis with a user-friendly interface.</li> <li>SimBiology (MATLAB) \u2013 A comprehensive system for mechanistic PK/PD and systems pharmacology modeling.</li> <li>Phoenix WinNonlin \u2013 A suite for pharmacokinetic analysis and regulatory submissions.</li> <li>PoPy \u2013 A Python-based tool designed for population PK/PD modeling. (Dual-licensed: Free for academic and educational use, commercial license required for industry applications and regulatory submissions)</li> <li>Berkeley Madonna \u2013 A commercial mathematical modeling software for solving differential equations, widely used in pharmacometrics. (Proprietary License)</li> <li>Pumas \u2013 A Julia-based platform for pharmaceutical modeling and simulation. (Proprietary: Free academic use, commercial license required for industry applications.)</li> </ul>"},{"location":"related-software/#suggestions-contributions","title":"Suggestions &amp; Contributions","text":"<p>Notice something missing or an issue in the lists above? Feel free to reach out if you know of a missing pharmacological modeling tool or have a suggestion for an update. We welcome community contributions to enhance the accuracy and usefulness of this resource!</p>"},{"location":"supporting/","title":"Supporting","text":"<p>I'm very happy that you've chosen to use QSPy. This project is one that I develop and maintain on my own time and without external funding. If you've found it helpful, here are a few ways you can support its ongoing development:</p> <ul> <li>Star  : Show your support by starring the QSPy GitHub repository. It helps increase the project's visibility and lets others know it's useful. It also benefits my motivation to continue improving the package!</li> <li>Share  : Sharing <code>QSPy</code> on your social media, forums, or with your network is another great way to support the project. It helps more people discover the package, which in turn motivates me to keep developing!</li> <li>Cite  : Citing or mentioning this software in your work, publications, or projects is another valuable way to support it. It helps spread the word and acknowledges the effort put into its development, which is greatly appreciated!</li> <li>Sponsor  : Even small financial contributions, such as spotting me the cost of a tea through Ko-fi so I can get my caffeine fix, can make a big difference! Every little bit can help me continue developing this and other open-source projects.</li> </ul> <p></p>"},{"location":"tutorials/","title":"\ud83d\udea7 Page Under Development \ud83d\udea7","text":"<p>Thank you for your interest in our Tutorials section! We\u2019re actively working on expanding these pages to provide step-by-step instructions and hands-on examples for using <code>qspy</code>.</p> <p>Our goal is to make these resources clear, practical, and easy to follow\u2014but we\u2019re still in the process of gathering content and refining details.</p> <p>Stay tuned! In the meantime:</p> <ul> <li>Have a specific question? Feel free to explore our existing documentation or reach out to the community.</li> <li>Want to contribute? If you have suggestions or example workflows, we'd love to hear from you!</li> </ul> <p>Check back soon for updates as we continue to improve these guides!</p>"}]}